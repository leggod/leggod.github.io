{"meta":{"title":"leggod","subtitle":"write less do more","description":"小破站不定时分享一些小惊喜~","author":"Xin Shan","url":"https://xinshani.github.io","root":"/"},"pages":[{"title":"关于","date":"2019-02-12T08:24:21.000Z","updated":"2022-04-06T01:45:23.125Z","comments":false,"path":"about/index.html","permalink":"https://xinshani.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-02-14T01:01:20.000Z","updated":"2022-04-06T01:45:23.125Z","comments":false,"path":"categories/index.html","permalink":"https://xinshani.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-02-13T08:53:39.000Z","updated":"2022-04-06T01:45:23.125Z","comments":false,"path":"tags/index.html","permalink":"https://xinshani.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"分享一些提升网上冲浪乐趣的工具","slug":"分享一些好东西——提升网上冲浪乐趣","date":"2021-06-16T02:53:32.000Z","updated":"2022-04-06T01:45:23.122Z","comments":true,"path":"p/9f7c15e8/","link":"","permalink":"https://xinshani.github.io/p/9f7c15e8/","excerpt":"","text":"注意 不可用于商业，且用且珍惜 v2ray不限速 1vmess://ewoidiI6ICIyIiwKInBzIjogIjIzM3YyLmNvbV8xNTIuNzAuMjUyLjE4NSIsCiJhZGQiOiAiMTUyLjcwLjI1Mi4xODUiLAoicG9ydCI6ICIxMDI2IiwKImlkIjogIjY3ZTM0NzYxLTMwMTgtNDc3NC1hMDNlLTI0NTUyYTA1Zjg2MSIsCiJhaWQiOiAiMCIsCiJuZXQiOiAid3MiLAoidHlwZSI6ICJub25lIiwKImhvc3QiOiAiIiwKInBhdGgiOiAiIiwKInRscyI6ICIiCn0K SSR(端口总被封)不限速，实际体验看运营商及服务器带宽。1ssr://MTUyLjcwLjI1Mi4xODU6MTAyNDphdXRoX3NoYTFfdjQ6YWVzLTI1Ni1jZmI6cGxhaW46Wkc5MVlpNXBidw MTProxy(GFW精准识别，gg)目前为止不限速，tg一键自动配置 1https://t.me/proxy?server=152.70.252.185&amp;port=1452&amp;secret=ddc6f9b0f80449639fc0aa54c296735a28 FRP支持http、tcp，目前为止不限速 配置举例12345678910111213141516[common]server_addr = frp.leggod.comserver_port = 7000token= frp.leggod.com[fdafdsa] //这随便写,千万别重复type = http# local_ip = 127.0.0.1local_port = 80subdomain = aaa //aaa.frp.leggod.com[fdafdafssh] //这随便写,千万别重复type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 48800 Bark 推送免费使用，急速推送，只需填入域名，可自动生成设备码1https://push.leggod.com","categories":[],"tags":[{"name":"MTProxy","slug":"MTProxy","permalink":"https://xinshani.github.io/tags/MTProxy/"},{"name":"SSR","slug":"SSR","permalink":"https://xinshani.github.io/tags/SSR/"},{"name":"FRP","slug":"FRP","permalink":"https://xinshani.github.io/tags/FRP/"}]},{"title":"使用docker搭建nginx+vue","slug":"使用docker搭建nginx-vue","date":"2019-06-21T03:05:51.000Z","updated":"2022-04-06T01:45:23.122Z","comments":true,"path":"p/51decd3/","link":"","permalink":"https://xinshani.github.io/p/51decd3/","excerpt":"","text":"写在开头 开发环境 Mac ，docker对 windows 并不友好，家庭版则直接放弃吧，个人觉得 docker 其实就是运行在本地的一个小型的 Linux 环境，只是它比虚拟机轻太多，反正如果实在懒得去搞清楚 docker 是啥，你需要把它当成操作系统去使用则好 其实需要知道 docker 的镜像和容器之说，好比 class 和 objec 一样。通俗点就是我们要装 windows 系统，需要有系统镜像，同理 docker 要让 Linux 容器跑起来，需要 Linux 镜像。 每一个镜像都有一个唯一 id 最后我们需要知道，每当我们不知怎么办，或者迷路的时候，记得 -h 很有帮助。 安装 万事开头难，windows 更难，Linux 其次，Mac 极其轻松。 docker 常用命令 查看镜像列表 docker images 查看运行的 docker 容器列表 docker ps 运行 docker 容器 docker run 安装 nginx 镜像及启动 假设我们的环境已经ok了，那么我们只需要1$ docker pull linux 基本运行12// 如果我们不把容器端口映射到本地，就算容器跑起来，你也访问不到。$ docker run -p [本地端口]:[容器端口] [镜像] 后台运行12//后台运行的时候我们可以做其他的事情$ docker run -d ... 交互运行并进入命令行模式12// 交互运行的时候，我们可以进入到容器，干一些事情，比如配置 nginx ，$ docker run -t -i container /bin/bash 实例运行 在后台运行一次 nginx 1$ docker run -d nginx || docker run -d 53f3fd8007f7 (ps: image id,推荐这种写法) 若有一串字母数字返回，那是container id ,说明容器已经跑起来了，再使用 docker ps 查看一下运行中容器，恭喜，可使用 docker stop [container id] 关闭容器 启动nginx 并进入命令行 1234567// 进入到 nginx 容器，并打开命令行$ docker run -it nginx /bin/bash// 同时输入 nginx -h 查看 nginx 的位置，我能查看到的信息显示，当前 nginx 的配置文件地址在:\"/etc/nginx/conf.d\"location 地址是:\"/usr/share/nginx/html\" 如果需要更改 nginx 配置，或者把要运行的项目放入到 nginx/html 目录 ，可以使用 拷贝命令例如：把 nginx config 复制到本地的/tmp 中1$ docker cp 96f7f14e99ab:/etc/nginx/conf.d/default.conf /tmp/至此我们可以使用 cp 把我们要运行的 vue 打包文件 cp 到 /usr/share/nginx/html/，并把 nginx 的 80端口映射到本地的 8080 。大功告成了？确实算是。但是对于我们开发来说太麻烦了，docker 有一项功能，叫数据卷，通俗讲可以实现 vue 打包后的 dist 目录直接映射到 容器 nginx 的 /usr/share/nginx/html/ 中。1$ docker -v 本地目录:容器目录 数据卷1$ docker run -d -p 81:80 -v /usr/local/var/www:/usr/share/nginx/html 53f3fd8007f7 命令说明： -p 81:80 把容器的80端口挂在到本地的81 -v /usr/local/var/www:/usr/share/nginx/html 把自己创建的www目录挂载到容html 此外在运行容器后，我们还可以使用 exec 进入到容器 1$ docker exec -it [CONTAINER ID] /bin/bash 祝，玩得开心","categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"}]},{"title":"搭建一个拿来即用的vue工程","slug":"搭建一个拿来即用的vue工程","date":"2019-02-19T02:30:37.000Z","updated":"2022-04-06T01:45:23.122Z","comments":true,"path":"p/aae69420/","link":"","permalink":"https://xinshani.github.io/p/aae69420/","excerpt":"","text":"前言&emsp;&emsp;前端真是一环扣一环，如果有些许react基础的同学，学起vue来可谓是飞快。如果有vue基础，写起小程序来，简直就是刷一遍文档的事情。每个项目都需要创建一个工程，如今vue-cli已经发展到3.0的时代了。一改2.0的臃肿，虽然用vue-cli一步一步傻瓜操作很容易创建一个新项目，但其实并不好用，还需要我们做一些工作，让开发变得更加得心应手。 准备安装node,最好使用nrm去切换一下npm源，或者使用淘宝镜像(其实并不推荐它，有些时候它所安装的路径会有问题，且它的速度并不是最快的) 1$ nrm use cnpm 安装 vue/cli,参照官网一步一步下一步。当把官方文档安装走一遍之后，这时，一个初步的脚手架工程就搭起来了。之后我们安装一些更适合我们开发的依赖 依赖 Less 1$ npm install -D less-loader less Less是css的预编译语言，你也可以选 SASS,Stylus。 之后我们在.vue写样式的时候 123&lt;style lang=\"less\" scoped&gt; ...&lt;/style&gt; vuex持久化 1$ npm install --save vuex-persistedstate vuex-persistedstate 是一款解决刷新后vuex states丢失的问题，可把vuex 写入本地存储，或者cookie;只需要简单配置:12345678// store.jsimport createPersistedState from 'vuex-persistedstate'export default new Vuex.Store(&#123; plugins: [createPersistedState(&#123;key: 'yourkey'&#125;)], state: &#123; &#125;, ...&#125;) CSS初始化 1$ npm install --save normalize.css normalize.css是CSS重置的现代替代方案，体积小，最大程度的屏蔽各浏览器差异。 12// main.jsimport \"normalize.css\" viewport解决方案 1$ npm install postcss-px-to-viewport –save-dev 之前在解决头疼的移动端布局问题上，我们使用的是rem,最有名的可能就是阿里在2015年双十一的Flexible,把rem这种方案推向了前端浪潮,随着浏览器对viewport的支持越来越好,viewport登上了前端舞台,可以参考一下移动端页面的适配,配置: 1234567891011//postcss.config.js'postcss-px-to-viewport': &#123; viewportWidth: 414, //你的viewport宽度 viewportHeight: ***,// viewport高度，可以不写 unitPrecision: 5, //转化后保留位数 viewportUnit: 'vw', //最好转化成vw,而不是vh selectorBlackList: ['.ignore', '.hairlines'], //黑名单 minPixelValue: 1, mediaQuery: false, //是否转化媒体查询 //exclude: /(\\/|\\\\)(node_modules)(\\/|\\\\)/ //如果想不转化node_modules文件&#125; vant有赞组件UI 1$ npm i vant -S 可去它的官网自己一步步来 vant 总结 至此，一个适合移动开发的vue脚手架可基本打造完成了。 如果有更好玩的，本文还是会更新的，还有些牛逼的vue 性能优化，让你的单页面在不借助服务器渲染的情况秒开，下一章再叙述","categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://xinshani.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"},{"name":"VUE","slug":"VUE","permalink":"https://xinshani.github.io/tags/VUE/"}]},{"title":"部署个人知识管理系统","slug":"部署个人知识管理系统","date":"2019-02-19T02:30:37.000Z","updated":"2022-04-24T04:26:33.726Z","comments":true,"path":"p/c9a18907/","link":"","permalink":"https://xinshani.github.io/p/c9a18907/","excerpt":"","text":"部署1docker run -v ~/siyuanworkspace:/siyuanworkspace -p 6806:6806 b3log/siyuan -resident -workspace /siyuanworkspace -accessAuthCode [你的密码]","categories":[{"name":"Docker","slug":"Docker","permalink":"https://xinshani.github.io/categories/Docker/"}],"tags":[]},{"title":"前端设计模式","slug":"前端设计模式","date":"2019-02-14T02:24:37.000Z","updated":"2022-04-06T01:45:23.122Z","comments":true,"path":"p/aba4a302/","link":"","permalink":"https://xinshani.github.io/p/aba4a302/","excerpt":"","text":"单例模式是什么? &emsp;&emsp;单例就是保证一个类只有一个实例，实现方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。 代码 单例模式的简单实现 es5 12345678910111213141516171819202122function Window(name) &#123; this.name = name;&#125;Window.prototype.getName = function () &#123; return this.name;&#125;//这是类上的方法，只可以通过类来访问,而不能通过实例来访问Window.getInstance = (function () &#123; let instance; return function (name) &#123; if (!instance) &#123; instance = new Window(name); &#125; return instance; &#125;&#125;)();let w1 = Window.getInstance();let w2 = Window.getInstance();console.log(w1 === w2) // --&gt; true es6 1234567891011121314class Window &#123; constructor(name) &#123; this.name = name; &#125; static getInstance() &#123; if (!this.instance) &#123; this.instance = new Window(); &#125; return this.instance; &#125;&#125;let w1 = Window.getInstance();let w2 = Window.getInstance();console.log(w1 === w2)","categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://xinshani.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"}]},{"title":"JS异步终极之路","slug":"JS异步终极之路","date":"2018-11-16T03:11:43.000Z","updated":"2022-04-06T01:45:23.117Z","comments":true,"path":"p/21a4feef/","link":"","permalink":"https://xinshani.github.io/p/21a4feef/","excerpt":"","text":"随着现代浏览器的不断发展，相信大家渐渐对ES6中的Promise已经有很多的使用了，其中对Promise.all估计也用的很多。Promise.all就是并行执行多个任务，然后在所有任务成功后触发then里面的内容，或者任意一个任务失败后触发catch里面的内容。 虽然Promise.all非常好用，但它也不是适合所有的场景，最常见的就是有些场景是需要串行的，一个任务列表要按顺序依次循环执行，任意一个失败就不触发下面的任务。那要实现这样的功能能怎么写呢？ 最简单的就是一个个写 var a = ()=&gt;{return new Promise((resolve, reject) =&gt; { setTimeout(resolve, 1000); });} var b = ()=&gt;{return new Promise((resolve, reject) =&gt; { setTimeout(resolve, 1000); });} var c = ()=&gt;{return new Promise((resolve, reject) =&gt; { setTimeout(resolve, 1000); });} a().then(()=&gt;{ return b() }).then(()=&gt;{ return c() }).then(()=&gt;{ console.log(&apos;after 3 sec&apos;) }) 这样写。。。真的好挫，更重要的是，有时候需要批量处理一个任务，都是调用同一个函数处理不定长度的数据，这样写肯定就不行了，比如要串行请求一串url。首先想到的是一个比较绕的方法，搞个Promise链出来，把下一个任务作为参数传到前一个的then中，如此循环。这种同一个函数不断循环然后把前一个处理完的值又传到参数里面，刚好和Array.reduce的思想是一致的，所以可以这么写： var urlArr = [&apos;http://www.qq.com&apos;,&apos;http://www.qq.com&apos;,&apos;http://www.qq.com&apos;]; function makaPromiseList(dataArr,handler) { return dataArr.reduce((promise, obj) =&gt; { return promise.then((ret) =&gt; { return handler(obj); }) }, Promise.resolve()) } var result = []; function makeRequest(url){ return new Promise((resolve,reject)=&gt;{ $.get(url).success((ret)=&gt;{ result.push(ret) resolve(result) }).fail(()=&gt;{ reject() }) }) } makaPromiseList(urlArr,makeRequest).then((result)=&gt;{ console.log(result) }); 不给力啊，理解起来就很绕，还要在闭包外面定义result存数据，用上reduce也觉得有点奇技淫巧，不太美观啊，能不能写得更好看点啊。 可以！说起异步方案，Promise是很强，但它还不是最强的，还有Promise的进阶版 —— async/await！号称JS异步的终极解决方案，真不是盖的，下面就来看看async/await的方案 var urlArr = [&apos;http://www.qq.com&apos;,&apos;http://www.qq.com&apos;,&apos;http://www.qq.com&apos;]; function makeRequest(url){ return new Promise((resolve,reject)=&gt;{ $.get(url).success((ret)=&gt;{ resolve(ret) }).fail(()=&gt;{ reject() }) }) } async function makaPromiseList(dataArr,handler){ var result = []; for(let item of dataArr){ var ret = await handler(item); result.push(ret); } return result; } makaPromiseList(urlArr,makeRequest).then((ret)=&gt;{ console.log(ret) }); 一个for循环解决串行异步问题，没有回调没有嵌套看起来瞬间舒服多了~","categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://xinshani.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"}]},{"title":"防运营商劫持","slug":"防运营商劫持","date":"2018-11-15T01:28:14.000Z","updated":"2022-04-06T01:45:23.124Z","comments":true,"path":"p/bdf71c77/","link":"","permalink":"https://xinshani.github.io/p/bdf71c77/","excerpt":"","text":"一、什么是运营商劫持什么是运营商：运营商是指那些提供宽带服务的ISP，包括三大运营商中国电信、中国移动、中国联通，还有一些小运营商，比如长城宽带、歌华有线宽带。运营商提供最最基础的网络服务，掌握着通往用户物理大门的钥匙，目前运营商劫持很普遍。（以前https其实就可以挡住很多了，但是现在的https劫持层出不穷，特别是app上面，而你的站点pv太大，劫持是一定的） 举个劫持的栗子： 劫持方式：运营商比较常见的作恶方式有三种，分别是DNS劫持、HTTP劫持、HTTPS劫持： DNS劫持：这种劫持会把你重新定位到其它网站，我们所熟悉的钓鱼网站就是这个原理。但是因为它的违法性，现在被严厉的监管起来，已经很少见。 HTTP劫持：虽然DNS劫持已经被监管了起来，但是还有HTTP劫持啊！你DNS解析的域名的IP地址不变，当运营商发现你的是HTTP请求时，就会在里面插入一些奇奇怪怪的广告（比如一些banner、浮标、更有甚把你你的商品位给劫持了 WTF…）并且这种现象十分常见，不信你可以试着随便打开一个网页，仔细看看你就会发现一些小尾巴，这就是被HTTP劫持了。 HTTPS劫持：安全的超文本传输协议，数据加密这也能劫持？答案是肯定的！该劫持方式有两种： 伪造证书，通过病毒或者其他方式将伪造证书的根证书安装在用户系统中（较少） 代理也有客户的证书与私钥，或者客户端与代理认证的时候不校验合法性，即可通过代理来与我们服务端进行数据交互（较多） 备注：使用本篇的代码一定会让你查到HTTPS劫持的（前提是使用了https） 二、防运营商劫持准确的来说是防script、iframe注入型劫持，95%以上是这种劫持方式，因为DNS劫持被严管了。 运营商是如何劫持的，网上有很多资料，这里不多逼逼 下面是防劫持代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;防劫持代码测试&lt;/title&gt; &lt;script&gt; console.log(&apos;发生劫持，初始化就直接置顶的流氓行为，暂无法防御，但可以通过埋点记录LOG，向工信部投诉！!&apos;); &lt;/script&gt; &lt;!-- 防劫持 --&gt; &lt;script shendun-eddy&gt; /** * @note 防劫持代码 * @key MutationObserver 提供了监视对DOM树所做更改的能力 */ (function() { var srcFilterTags = [&apos;script&apos;, &apos;iframe&apos;]; // 域名白名单 可以加多个 var whiteList = [&apos;zeptojs.com&apos;]; var whiteListReg = []; // 正则匹配 whiteList.forEach(function(wl) { var wlReg = new RegExp(&apos;/.+?\\/\\/&apos; + wl + &apos;|\\/\\/&apos; + wl + &apos;|.+?\\.&apos; + wl + &apos;|^&apos; + wl); whiteListReg.push(wlReg); }); // 白名单助手 var inWhileList = function(addedNode) { // shendun-eddy 是script的白名单标签 if (addedNode.src === &apos;&apos; &amp;&amp; addedNode.getAttribute(&apos;shendun-eddy&apos;) !== null) { return true; } var isInWhiteList = false; whiteListReg.forEach(function(wlReg) { if (wlReg.test(addedNode.src)) { isInWhiteList = true; return false; } }); return isInWhiteList; }; // dom观察器 var mutationHandler = function(records) { records.forEach(function(record) { Array.prototype.slice.call(record.addedNodes).forEach(function(addedNode) { srcFilterTags.forEach(function(tagName) { // 标签匹配 白名单匹配 if (addedNode.tagName === tagName.toUpperCase() &amp;&amp; !inWhileList(addedNode)) { addedNode.remove(); }; }); }); }) }; // 核心 - MutationObserver 提供了监视对DOM树所做更改的能力 // 优点 - 动态监听是否有非法的 iframe 和 script 代码 // 缺点 - 无法查找头部直接插入的代码 var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver, observeMutationSupport = !!MutationObserver; var html = document.getElementsByTagName(&apos;html&apos;)[0]; if (observeMutationSupport) { new MutationObserver(mutationHandler).observe(html, { &apos;childList&apos;: true, &apos;subtree&apos;: true }); } // 唯独直接加载的不能remove掉，异步加载的都能remove掉！！ // *** 记录头部的script，通知工信部 *** var eleList = document.querySelectorAll(&apos;script&apos;); var len = eleList.length; for (var i = 0; i &lt; len; i++) { // 遍历操作 if (!inWhileList(eleList[i])) { // do sth 这里的删除虽然已经晚了，因为头部同步JS已被执行，删除操作意义不大，但可以统计被劫持的代码是什么，记录好LOG 通知工信部 // sendLog eleList[i].remove(); } } })(); &lt;/script&gt; &lt;script&gt;console.log(&quot;劫持1&quot;);&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;防劫持代码测试&lt;/div&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;bro&quot;&gt; &lt;div class=&quot;xiongdei&quot;&gt; &lt;script src=&quot;https://mt.cnzz.com/js/hdpi_canvas.js&quot;&gt;&lt;/script&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;http://zeptojs.com/zepto.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 这里执行了 console.log(&apos;哎哟，我来劫持你了...&apos;); 虽然访问了这个script, 但被remove了不会执行--&gt; &lt;script src=&quot;http://nansenzsl.coding.me/CBS/shendun_test.js&quot;&gt;&lt;/script&gt; &lt;script&gt;console.log(&quot;劫持....&quot;);&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 加入运营商劫持代码后，不在白名单和安全标签（shendun-eddy）内的script或者iframe都会被remove掉。 核心功能MutationObserver()创建并返回一个新的 MutationObserver 它会在指定的DOM发生变化时被调用。 具体参数和用法传送门：developer.mozilla.org/zh-CN/docs/… 兼容性 所有浏览器的兼容性是92.79%，手机端的兼容性更高，代码中加了保护所以放心使用吧！ 三、总结目前运营商劫持率大约是3% ~ 25%，它们无处不在。 为了还用户一个干净安全的浏览环境，我们需要做好预防措施 全站https，能防一部分 加入防运营商劫持代码，能防大部分注入型劫持 记录Log，记录证据，向工信部投诉","categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"}]},{"title":"你应该知道的 JavaScript Array.map() 的 5 种用途","slug":"你应该知道的 JavaScript Array.map() 的 5 种用途","date":"2018-11-14T00:48:55.000Z","updated":"2022-04-06T01:45:23.121Z","comments":false,"path":"p/a97afcc8/","link":"","permalink":"https://xinshani.github.io/p/a97afcc8/","excerpt":"","text":"从经典的 for 循环到 forEach() 方法，用于迭代数据集合的各种技术和方法比比皆是。但是现在比较流行的方法是 .map() 方法。 .map() 通过指定函数调用一个数组中每一项元素，来创建一个新数组。 .map() 是一种 non-mutating(非变异) 方法，它创建一个新数组，而不是只对调用数组进行更改的 mutating(变异) 方法。这可能很难记住。 在这篇文章中，我们将探讨一下 JavaScript 中 .map() 的 4 个值得注意的用法。让我们开始！ 在数组中的每一项元素上调用一个函数 将字符串转换为数组 在 JavaScript 库中用于渲染列表 重新格式化数组对象 小技巧使用案例 1. 在数组中的每一项元素上调用一个函数如前所述，.map() 接受回调函数作为其参数之一，该函数的一个重要参数是由该函数处理的项的当前值。这是一个必需的参数。有了这个参数，我们可以修改数组中的每个单独项，并在其上创建一个新元素。这里有一个例子： const sweetArray = [2, 3, 4, 5, 35] const sweeterArray = sweetArray.map(sweetItem =&gt; { return sweetItem * 2 }) console.log(sweetArray) // [2, 3, 4, 5, 35] console.log(sweeterArray) // [4, 6, 8, 10, 70] 我们可以看到，原数组 sweetArray 并没有被修改，所以 .map() 是一种 non-mutating(非变异) 方法。这里值得一提的是 forEach() 方法，它是遍历数组，对原来的数据操作，会改变原数组。 这甚至可以进一步简化，使其更清洁： // 创建一个要使用的函数 const makeSweeter = sweetItem =&gt; sweetItem * 2; // 我们有一个数组 const sweetArray = [2, 3, 4, 5, 35]; // 调用我们制作的函数。更具可读性 const sweeterArray = sweetArray.map(makeSweeter); console.log(sweeterArray); // [4, 6, 8, 10, 70] 拥有像 sweetArray.map(makeSweeter) 这样的代码可以让你在跳转到这段代码时更具可读性。 将字符串转换为数组已知的 .map() 属于 Array 原型。 我们如何使用它将字符串转换为数组。 不用担心，我们不需要再开发一个方法来处理字符串，而是使用特殊的 .call() 方法。 JavaScript 中的所有内容都是对象，方法只是附加到这些对象的函数。 .call() 允许我们利用另一个对象的上下文。 因此，我们将数组中的 .map() 上下文复制到字符串。 .call() 可以传递参数，要使用的上下文和“参数原始函数的参数”。 听起来有点拗口？ 这是一个例子： const name = &quot;Chuloo&quot; const map = Array.prototype.map const newName = map.call(name, eachLetter =&gt; { return `${eachLetter}a` }) console.log(newName) // [&quot;Ca&quot;, &quot;ha&quot;, &quot;ua&quot;, &quot;la&quot;, &quot;oa&quot;, &quot;oa&quot;] 这里，我们只是在String上使用 .map() 的上下文，并传递了 .map() 所期望的函数参数。 你可以看看控制台里打印出来的内容。 这类似于 String 的 .split() 方法，不过 .split() 方法只能在返回数组之前修改每个单独的字符串字符。 在 JavaScript 库中用于渲染列表像 React 这样的 JavaScript 库利用 .map() 来渲染列表中的项目。这需要 JSX 语法，但是 .map() 方法包含在类似于 mustache 的 JSX 语法中。这是 React 组件的一个很好的例子。 import React from &quot;react&quot;; import ReactDOM from &quot;react-dom&quot;; const names = [&quot;john&quot;, &quot;sean&quot;, &quot;mike&quot;, &quot;jean&quot;, &quot;chris&quot;]; const NamesList = () =&gt; ( {names.map(name =&gt; {name} )} ); const rootElement = document.getElementById(&quot;root&quot;); ReactDOM.render(, rootElement); 如果你不熟悉 React ，那么我告诉这是 React 中的一个简单的无状态组件，它使用列表渲染div。 使用 .map() 渲染单个列表项以迭代最初创建的 names 数组。 此组件使用 ReactDOM 渲染 ID为 root 的 DOM 元素 。 重新格式化数组对象如何处理数组中的对象？ .map() 可用于迭代数组中的对象，并以与传统数组类似的方式，修改每个单独对象的内容 并返回一个新数组。 这个修改是基于回调函数中返回的内容来完成的。这里有一个例子: const myUsers = [ { name: &apos;chuloo&apos;, likes: &apos;grilled chicken&apos; }, { name: &apos;chris&apos;, likes: &apos;cold beer&apos; }, { name: &apos;sam&apos;, likes: &apos;fish biscuits&apos; } ] const usersByFood = myUsers.map(item =&gt; { const container = {}; container[item.name] = item.likes; container.age = item.name.length * 10; return container; }) console.log(usersByFood); // [{chuloo: &quot;grilled chicken&quot;, age: 60}, {chris: &quot;cold beer&quot;, age: 50}, {sam: &quot;fish biscuits&quot;, age: 30}] 我们所做的就是使用括号和点符号简单地修改数组中的每个对象。这个用例可以用于在前端应用程序上保存或解析之前处理或压缩接收到的数据。 小技巧使用案例通常情况下，.map() 方法中的 callback 函数只需要接受一个参数，就是正在被遍历的数组元素本身。但这并不意味着 map 只给 callback 传了一个参数。这个思维惯性可能会让我们犯一个很容易犯的错误。 生成新数组元素的 callback 函数，有 三个参数： currentValue – callback 的第一个参数，数组中正在处理的当前元素，最常用的参数。 index – callback 的第二个参数，数组中正在处理的当前元素的索引。 array – callback 的第三个参数，map 方法被调用的数组。 来看一下例子： // 下面的语句返回什么呢: [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt); // 你可能觉的会是[1, 2, 3] // 但实际的结果是 [1, NaN, NaN] // 通常使用parseInt时,只需要传递一个参数. // 但实际上,parseInt可以有两个参数.第二个参数是进制数. // 可以通过语句&quot;alert(parseInt.length)===2&quot;来验证. // map方法在调用callback函数时,会给它传递三个参数:当前正在遍历的元素, // 元素索引, 原数组本身. // 第三个参数parseInt会忽视, 但第二个参数不会,也就是说, // parseInt把传过来的索引值当成进制数来使用.从而返回了NaN. function returnInt(element) { return parseInt(element, 10); } [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map(returnInt); // [1, 2, 3] // 意料之中的结果 // 也可以使用简单的箭头函数，结果同上 [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map( str =&gt; parseInt(str) ); // 一个更简单的方式: [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map(Number); // [1, 2, 3] // 与`parseInt` 不同，下面的结果会返回浮点数或指数: [&apos;1.1&apos;, &apos;2.2e2&apos;, &apos;3e300&apos;].map(Number); // [1.1, 220, 3e+300] 还有一个非常实用的小技巧，像 .map() ，.reduce(), .filter() 这些方法支持链式调用。例如： var myArr = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]; var result = myArr .map(function(element) { // 数值大于5的数值视为5 if (element &gt; 5) return 5; return element; }) .reduce(function(prev, element) { // 与之前的数值加总，回传后代入下一轮的处理 return prev + element; }, 0); // 40 console.log(result); 小结在这篇文章中，我们研究了 JavaScript 中 .map() 方法的主要用途。 需要注意的是，与其他方法结合使用时，.map() 的函数可以得到强大的扩展和利用。","categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"}]},{"title":"Vue.js 你不知道的奇技淫巧","slug":"Vue.js 你不知道的奇技淫巧","date":"2018-11-13T00:44:42.000Z","updated":"2022-04-06T01:45:23.118Z","comments":true,"path":"p/1a98f637/","link":"","permalink":"https://xinshani.github.io/p/1a98f637/","excerpt":"","text":"给 props 属性设置多个类型 这个技巧在开发组件的时候用的较多，为了更大的容错性考虑。比如一个 &lt;my-button&gt; 上暴露了一个 width 属性：1234567// my-button.vueexport default &#123; props: &#123; width: [String, Number], default: '100px' &#125;&#125;我们既可以传 100px，也可以传 100 。123456789101112131415161718192021&lt;!-- my-button.vue --&gt;&lt;template&gt; &lt;button :style=\"computedWidth\"&gt;width: &#123; &#123; computedWidth &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; width: [String, Number], default: '100px' &#125;, computed: &#123; computedWidth () &#123; let o = &#123;&#125; if (typeof this.width === 'string') o.width = this.width if (typeof this.width === 'number') o.width = this.width + 'px' return o &#125; &#125; &#125;&lt;/script&gt;使用：123456&lt;!-- 在其他组件中使用 --&gt;&lt;template&gt; &lt;my-button :width=\"100px\"&gt;&lt;/my-button&gt; &lt;!-- or --&gt; &lt;my-button :width=\"100\"&gt;&lt;/my-button&gt;&lt;/template&gt;初始化 因为 props 要比 data 先完成初始化，所以我们可以利用这一点给 data 初始化一些数据进去，看代码：12345678910export default &#123; data () &#123; return &#123; buttonSize: this.size &#125; &#125;, props: &#123; size: String &#125;&#125;除了以上，子组件的 data 函数也可以有参数，且该参数是当前实例对象。所有我们可以利用这一点做一些自己的判断。如，改写上面的代码：12345678910export default &#123; data (vm) &#123; return &#123; buttonSize: vm.size &#125; &#125;, props: &#123; size: String &#125;&#125;template 我们在做 v-if 判断的时候，可以把判断条件放在 template 组件上，最终的渲染结果将不包含 &lt;template&gt; 元素。12345678910&lt;template&gt; &lt;div class=\"box\"&gt; &lt;template v-if=\"isVal\"&gt; &lt;h2&gt;...&lt;/h2&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;h2&gt;...&lt;/h2&gt; &lt;/template&gt; &lt;/div&gt;&lt;/template&gt;v-for 也同样适用。 Lifecycle hook 生命周期钩子可以是一个数组类型，且数组中的函数会依次执行。123456789101112export default &#123; ... created: [ function one () &#123; console.log(1) &#125;, function two () &#123; console.log(2) &#125; ] ...&#125;没什么用，知道就行了。事实上生命周期钩子还可以作用于 DOM 元素上，利用这一点，我们可以用父组件中的方法来初始化子组件的生命周期钩子：123456789101112131415161718192021&lt;!-- Child.vue --&gt;&lt;template&gt; &lt;h3&gt;I'm child!&lt;/h3&gt;&lt;/template&gt;&lt;!-- Parent.vue --&gt;&lt;template&gt; &lt;child @hook:created=\"handleChildCreated\"&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt; import Child from './child.vue' export default &#123; components: [ Child ], methods: &#123; handleChildCreated () &#123; console.log('handle child created...') &#125; &#125; &#125;&lt;/script&gt;其他钩子雷同，不再赘述。 v-for 和 v-if 一起使用 由于 v-for 比 v-if 渲染优先级更高，所以有时候可以一起使用。下面两种常见的情况下会倾向于把 v-for 和 v-if 放在同一个标签上使用： 筛选一些不想显示的条目 为了避免渲染本应该被隐藏的列表 举个栗子：1234567891011&lt;template&gt; &lt;ul class=\"items\"&gt; &lt;!-- 只有激活的用户才可以显示 --&gt; &lt;li v-for=\"(user, index) in users\" v-if=\"user.isActive\" :key=\"user.id\"&gt; &#123; &#123; user.name &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;关于以上两点不明白的地方可以参见 Vue 风格指南。 混合 如果好多组件都共用到一些像 props、data、methods 等，可以单独抽出来放到 mixins 混合器中。比如，在用户管理列表中使用。 分页混合器：1234567891011121314151617181920212223242526272829// paging-mixin.vueexport default &#123; props: &#123; pageSize: 1, pageLength: 10, currentPage: 1 total: 20 &#125;, methods: &#123; /** * 上一页 */ prevPage (page) &#123; ... &#125;, /** * 下一页 */ nextPage (page) &#123; ... &#125; /** * 跳转到当前页 */ currentPage (page) &#123; ... &#125; &#125;&#125;Users.vue:123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class=\"user-model\"&gt; &lt;my-table :data=\"users\"&gt;&lt;/my-table&gt; &lt;my-paging :page-length=\"pageLength\" :page-size=\"pageSize\" :current-page=\"currentPage\" :total=\"total\"&gt; &lt;/my-paging&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import PagingMixin from '../mixins/paging-mixin.vue' export default &#123; mixins: [PagingMixin], data () &#123; return &#123; users: [], pageLength: 10, pageSize: 1, currentPage: 1, total: 20 &#125; &#125; &#125;&lt;/script&gt;不用每个页面都写一遍 props 和 methods 了。 render 函数 下面是一段简单的 template 模板代码：123456&lt;template&gt; &lt;div class=\"box\"&gt; &lt;h2&gt;title&lt;/h2&gt; this is content &lt;/div&gt;&lt;/template&gt;我们用渲染函数来重写上面的代码：12345678export default &#123; render (h) &#123; let _c = h return _c('div', &#123; class: 'box'&#125;, [_c('h2', &#123;&#125;, 'title'), 'this is content']) &#125;&#125;事实上，Vue 会把模板(template)编译成渲染函数(render)，你可以通过一个在线工具 实时查看编译结果。上面的 template 模板会被编译成如下渲染函数：12345let render = function () &#123; return _c('div', &#123;staticClass:\"box\"&#125;, [_c('h2', [_v(\"title\")]), _v(\"this is content\")])&#125;是不是很像？ 正如官方说的，渲染函数比 template 更接近编译器。如果用一个流程图来解释的话，大概是这个样子：1234567template ↓预编译工具（vue-loader + vue-template-compile） ↓ render ↓resolve vnode具体参见 Vue声明周期图示。 渲染函数用处： 开发组件库，Element 源码用的都是 render 封装一些高阶组件。组件里面嵌套组件就是高阶组件，前提是要满足组件三要素：props、event、slot 用于处理一些复杂的逻辑判断。如果我们一个组件里面有很多 v-if 判断的话，用模板就显得不合适了，这个时候可以用渲染函数来轻松处理 errorCaptured 捕获一个来自子孙组件的错误时被调用。有时候当我们想收集错误日志，却不想把错误暴露到浏览器控制台的时候，这很有用。下面是个例子： Child.vue1234567891011&lt;template&gt; &lt;!-- 省略一些无关代码 --&gt;&lt;/template&gt;&lt;script&gt; export default &#123; mounted () &#123; // 故意把 console 写错 consol.log('这里会报错！') &#125; &#125;&lt;/script&gt;Parent.vue123456789101112131415161718192021222324252627&lt;template&gt; &lt;child&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt; import Child from './Child.vue' export default &#123; components: [ Child ], /** * 收到三个参数： * 错误对象、发生错误的组件实例 * 以及一个包含错误来源信息的字符串。 * 此钩子可以返回 false 以阻止该错误继续向上传播。 */ errorCaptured (err, vm, info) &#123; console.log(err) // -&gt; ReferenceError: consle is not defined ... console.log(vm) // -&gt; &#123;_uid: 1, _isVue: true, $options: &#123;…&#125;, _renderProxy: o, _self: o,…&#125; console.log(info) // -&gt; `mounted hook` // 告诉我们这个错误是在 vm 组件中的 mounted 钩子中发生的 // 阻止该错误继续向上传播 return false &#125; &#125;&lt;/script&gt;关于 errorCaptured 更多说明，请移步官网-&gt; 。 v-once 通过 v-once 创建低开销的静态组件。渲染普通的 HTML 元素在 Vue 中是非常快速的，但有的时候你可能有一个组件，这个组件包含了大量静态内容。在这种情况下，你可以在根元素上添加 v-once 特性以确保这些内容只计算一次然后缓存起来，就像这样：123456&lt;template&gt; &lt;div class=\"box\" v-once&gt; &lt;h2&gt; 用户协议 &lt;/h2&gt; ... a lot of static content ... &lt;/div&gt;&lt;/template&gt;只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。关于 v-once 更多介绍，请移步官网-&gt;。 slot-scope 作用域插槽。`vue@2.5.0版本以前叫scope，之后的版本用slot-scope将其代替。除了 scope 只可以用于元素，其它和slot-scope都相同。 用过 Element 组件的同学都知道，当我们在使用 [](https://link.juejin.im?target=http%3A%2F%2Felement-cn.eleme.io%2F2.4%2F%23%2Fzh-CN%2Fcomponent%2Ftable%23zi-ding-yi-lie-mo-ban) 的时候会看到如下代码： Element@1.4.x 的版本： 1234567891011&lt;el-table-column label=\"操作\"&gt; &lt;template scope=\"scope\"&gt; &lt;el-button size=\"small\" @click=\"handleEdit(scope.$index, scope.row)\"&gt;编辑&lt;/el-button&gt; &lt;el-button size=\"small\" type=\"danger\" @click=\"handleDelete(scope.$index, scope.row)\"&gt;删除&lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt; 但在 2.0 之后的版本替换成了slot-scope。 Element@2.0.11： 1234567891011&lt;el-table-column label=\"操作\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;el-button size=\"mini\" @click=\"handleEdit(scope.$index, scope.row)\"&gt;编辑&lt;/el-button&gt; &lt;el-button size=\"mini\" type=\"danger\" @click=\"handleDelete(scope.$index, scope.row)\"&gt;删除&lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt; 说白了，slot-scope相当于函数的回调，我把结果给你，你想怎么处理就怎么处理，一切随你： 1234567891011121314function getUserById (url, data, callback) &#123; $.ajax(&#123; url, data, success: function (result) &#123; callback(result) &#125; &#125;)&#125;// 使用getUserById('/users', &#123; id: 1 &#125;, function (response) &#123; // 拿到数据并开始处理自己的页面逻辑&#125;) 下面我们来简单模拟下组件内部是怎么使用slot-scope的，看代码： 模拟的组件： 1234567891011121314151617181920// 定义模板let template = ` &lt;ul class=\"table\"&gt; &lt;li v-for=\"(item, index) in data\" :key=\"index\"&gt; &lt;!-- 我希望数据由调用者自己处理 --&gt; &lt;!-- 'row' 相当于变量名，随便起名 --&gt; &lt;slot :row=\"item\"&gt; &lt;!-- 当使用者什么都没写的时候，默认值才会显示--&gt; &#123; &#123; item.name &#125;&#125; &lt;/slot&gt; &lt;/li&gt; &lt;/ul&gt;`Vue.component('el-table', &#123; template, props: &#123; data: Array, default: [] &#125;&#125;) 在你需要的地方使用组件： HTML: 1234567891011121314&lt;div id=\"app\"&gt; &lt;el-table :data=\"userData\"&gt; &lt;!-- 使用的时候可以用 template --&gt; &lt;!-- `scope` 只是个形参，随便起名 --&gt; &lt;template slot-scope=\"scope\"&gt; &lt;template v-if=\"scope.row.isActived\"&gt; &lt;span class=\"red\"&gt;&#123; &#123; scope.row.name &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;template v-else&gt; &#123; &#123; scope.row.name &#125;&#125; &lt;/template&gt; &lt;/template&gt; &lt;/el-table&gt;&lt;/div&gt; JavaScript: 1234567891011new Vue(&#123; el: '#app', data: &#123; userData: [ &#123;id: 1, name: '张三', isActived: false&#125;, &#123;id: 2, name: '李四', isActived: false&#125;, &#123;id: 1, name: '王五', isActived: true&#125;, &#123;id: 1, name: '赵六', isActived: false&#125;, ] &#125;&#125;) CSS: 123.red &#123; color: red&#125; 我们完全可以在中进行逻辑判断，为什么还要放到外面进行处理呢？ 因为有时候我们用的不是自己开发的组件，比如上面的` ，所以就有必要这么做了。最后，你可以狠狠的戳这里查看效果！","categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://xinshani.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"}]},{"title":"ES6 系列之 defineProperty 与 proxy","slug":"ES6 系列之 defineProperty 与 proxy","date":"2018-11-11T14:34:50.000Z","updated":"2022-04-06T01:45:23.116Z","comments":true,"path":"p/35cb3085/","link":"","permalink":"https://xinshani.github.io/p/35cb3085/","excerpt":"","text":"前言我们或多或少都听过“数据绑定”这个词，“数据绑定”的关键在于监听数据的变化，可是对于这样一个对象：var obj = {value: 1}，我们该怎么知道 obj 发生了改变呢？ definePropetyES5 提供了 Object.defineProperty 方法，该方法可以在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。 语法 Object.defineProperty(obj, prop, descriptor) 参数 obj: 要在其上定义属性的对象。 prop: 要定义或修改的属性的名称。 descriptor: 将被定义或修改的属性的描述符。 举个例子： var obj = {}; Object.defineProperty(obj, &quot;num&quot;, { value : 1, writable : true, enumerable : true, configurable : true }); // 对象 obj 拥有属性 num，值为 1 虽然我们可以直接添加属性和值，但是使用这种方式，我们能进行更多的配置。 函数的第三个参数 descriptor 所表示的属性描述符有两种形式：数据描述符和存取描述符。 两者均具有以下两种键值： configurable 当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，也能够被删除。默认为 false。 enumerable 当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。 数据描述符同时具有以下可选键值： value 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。 writable 当且仅当该属性的 writable 为 true 时，该属性才能被赋值运算符改变。默认为 false。 存取描述符同时具有以下可选键值： get 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。 set 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。 值得注意的是： 属性描述符必须是数据描述符或者存取描述符两种形式之一，不能同时是两者。这就意味着你可以： Object.defineProperty({}, &quot;num&quot;, { value: 1, writable: true, enumerable: true, configurable: true }); 也可以： var value = 1; Object.defineProperty({}, &quot;num&quot;, { get : function(){ return value; }, set : function(newValue){ value = newValue; }, enumerable : true, configurable : true }); 但是不可以： // 报错 Object.defineProperty({}, &quot;num&quot;, { value: 1, get: function() { return 1; } }); 此外，所有的属性描述符都是非必须的，但是 descriptor 这个字段是必须的，如果不进行任何配置，你可以这样： var obj = Object.defineProperty({}, &quot;num&quot;, {}); console.log(obj.num); // undefined Setters 和 Getters之所以讲到 defineProperty，是因为我们要使用存取描述符中的 get 和 set，这两个方法又被称为 getter 和 setter。由 getter 和 setter 定义的属性称做”存取器属性“。 当程序查询存取器属性的值时，JavaScript 调用 getter方法。这个方法的返回值就是属性存取表达式的值。当程序设置一个存取器属性的值时，JavaScript 调用 setter 方法，将赋值表达式右侧的值当做参数传入 setter。从某种意义上讲，这个方法负责“设置”属性值。可以忽略 setter 方法的返回值。 举个例子： var obj = {}, value = null; Object.defineProperty(obj, &quot;num&quot;, { get: function(){ console.log(&apos;执行了 get 操作&apos;) return value; }, set: function(newValue) { console.log(&apos;执行了 set 操作&apos;) value = newValue; } }) obj.num = 1 // 执行了 set 操作 console.log(obj.num); // 执行了 get 操作 // 1 这不就是我们要的监控数据改变的方法吗？我们再来封装一下： function Archiver() { var value = null; // archive n. 档案 var archive = []; Object.defineProperty(this, &apos;num&apos;, { get: function() { console.log(&apos;执行了 get 操作&apos;) return value; }, set: function(value) { console.log(&apos;执行了 set 操作&apos;) value = value; archive.push({ val: value }); } }); this.getArchive = function() { return archive; }; } var arc = new Archiver(); arc.num; // 执行了 get 操作 arc.num = 11; // 执行了 set 操作 arc.num = 13; // 执行了 set 操作 console.log(arc.getArchive()); // [{ val: 11 }, { val: 13 }] watch API既然可以监控数据的改变，那我可以这样设想，即当数据改变的时候，自动进行渲染工作。举个例子： HTML 中有个 span 标签和 button 标签 &lt;span id=&quot;container&quot;&gt;1&lt;/span&gt; &lt;button id=&quot;button&quot;&gt;点击加 1&lt;/button&gt; 当点击按钮的时候，span 标签里的值加 1。 传统的做法是： document.getElementById(&apos;button&apos;).addEventListener(&quot;click&quot;, function(){ var container = document.getElementById(&quot;container&quot;); container.innerHTML = Number(container.innerHTML) + 1; }); 如果使用了 defineProperty： var obj = { value: 1 } // 储存 obj.value 的值 var value = 1; Object.defineProperty(obj, &quot;value&quot;, { get: function() { return value; }, set: function(newValue) { value = newValue; document.getElementById(&apos;container&apos;).innerHTML = newValue; } }); document.getElementById(&apos;button&apos;).addEventListener(&quot;click&quot;, function() { obj.value += 1; }); 代码看似增多了，但是当我们需要改变 span 标签里的值的时候，直接修改 obj.value 的值就可以了。 然而，现在的写法，我们还需要单独声明一个变量存储 obj.value 的值，因为如果你在 set 中直接 obj.value = newValue 就会陷入无限的循环中。此外，我们可能需要监控很多属性值的改变，要是一个一个写，也很累呐，所以我们简单写个 watch 函数。使用效果如下： var obj = { value: 1 } watch(obj, &quot;num&quot;, function(newvalue){ document.getElementById(&apos;container&apos;).innerHTML = newvalue; }) document.getElementById(&apos;button&apos;).addEventListener(&quot;click&quot;, function(){ obj.value += 1 }); 我们来写下这个 watch 函数： (function(){ var root = this; function watch(obj, name, func){ var value = obj[name]; Object.defineProperty(obj, name, { get: function() { return value; }, set: function(newValue) { value = newValue; func(value) } }); if (value) obj[name] = value } this.watch = watch; })() 现在我们已经可以监控对象属性值的改变，并且可以根据属性值的改变，添加回调函数，棒棒哒~ proxy使用 defineProperty 只能重定义属性的读取（get）和设置（set）行为，到了 ES6，提供了 Proxy，可以重定义更多的行为，比如 in、delete、函数调用等更多行为。 Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。我们来看看它的语法： var proxy = new Proxy(target, handler); proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。 var proxy = new Proxy({}, { get: function(obj, prop) { console.log(&apos;设置 get 操作&apos;) return obj[prop]; }, set: function(obj, prop, value) { console.log(&apos;设置 set 操作&apos;) obj[prop] = value; } }); proxy.time = 35; // 设置 set 操作 console.log(proxy.time); // 设置 get 操作 // 35 除了 get 和 set 之外，proxy 可以拦截多达 13 种操作，比如 has(target, propKey)，可以拦截 propKey in proxy 的操作，返回一个布尔值。 // 使用 has 方法隐藏某些属性，不被 in 运算符发现 var handler = { has (target, key) { if (key[0] === &apos;_&apos;) { return false; } return key in target; } }; var target = { _prop: &apos;foo&apos;, prop: &apos;foo&apos; }; var proxy = new Proxy(target, handler); console.log(&apos;_prop&apos; in proxy); // false 又比如说 apply 方法拦截函数的调用、call 和 apply 操作。 apply 方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组，不过这里我们简单演示一下： var target = function () { return &apos;I am the target&apos;; }; var handler = { apply: function () { return &apos;I am the proxy&apos;; } }; var p = new Proxy(target, handler); p(); // &quot;I am the proxy&quot; 又比如说 ownKeys 方法可以拦截对象自身属性的读取操作。具体来说，拦截以下操作： Object.getOwnPropertyNames() Object.getOwnPropertySymbols() Object.keys() 下面的例子是拦截第一个字符为下划线的属性名，不让它被 for of 遍历到。 let target = { _bar: &apos;foo&apos;, _prop: &apos;bar&apos;, prop: &apos;baz&apos; }; let handler = { ownKeys (target) { return Reflect.ownKeys(target).filter(key =&gt; key[0] !== &apos;_&apos;); } }; let proxy = new Proxy(target, handler); for (let key of Object.keys(proxy)) { console.log(target[key]); } // &quot;baz&quot; 更多的拦截行为可以查看阮一峰老师的 《ECMAScript 6 入门》 值得注意的是，proxy 的最大问题在于浏览器支持度不够，而且很多效果无法使用 poilyfill 来弥补。 watch API 优化我们使用 proxy 再来写一下 watch 函数。使用效果如下： (function() { var root = this; function watch(target, func) { var proxy = new Proxy(target, { get: function(target, prop) { return target[prop]; }, set: function(target, prop, value) { target[prop] = value; func(prop, value); } }); return proxy; } this.watch = watch; })() var obj = { value: 1 } var newObj = watch(obj, function(key, newvalue) { if (key == &apos;value&apos;) document.getElementById(&apos;container&apos;).innerHTML = newvalue; }) document.getElementById(&apos;button&apos;).addEventListener(&quot;click&quot;, function() { newObj.value += 1 }); 我们也可以发现，使用 defineProperty 和 proxy 的区别，当使用 defineProperty，我们修改原来的 obj 对象就可以触发拦截，而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截。","categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://xinshani.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"}]},{"title":"JavaScript 复杂判断的更优雅写法","slug":"JavaScript 复杂判断的更优雅写法","date":"2018-11-08T02:39:47.000Z","updated":"2022-04-06T01:45:23.117Z","comments":true,"path":"p/95460080/","link":"","permalink":"https://xinshani.github.io/p/95460080/","excerpt":"","text":"JavaScript 复杂判断的更优雅写法前提我们编写js代码时经常遇到复杂逻辑判断的情况，通常大家可以用if/else或者switch来实现多个条件判断，但这样会有个问题，随着逻辑复杂度的增加，代码中的if/else/switch会变得越来越臃肿，越来越看不懂，那么如何更优雅的写判断逻辑，本文带你试一下。 举个例子先看一段代码 /** * 按钮点击事件 * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消 */ const onButtonClick = (status)=&gt;{ if(status == 1){ sendLog(&apos;processing&apos;) jumpTo(&apos;IndexPage&apos;) }else if(status == 2){ sendLog(&apos;fail&apos;) jumpTo(&apos;FailPage&apos;) }else if(status == 3){ sendLog(&apos;fail&apos;) jumpTo(&apos;FailPage&apos;) }else if(status == 4){ sendLog(&apos;success&apos;) jumpTo(&apos;SuccessPage&apos;) }else if(status == 5){ sendLog(&apos;cancel&apos;) jumpTo(&apos;CancelPage&apos;) }else { sendLog(&apos;other&apos;) jumpTo(&apos;Index&apos;) } } 通过代码可以看到这个按钮的点击逻辑：根据不同活动状态做两件事情，发送日志埋点和跳转到对应页面，大家可以很轻易的提出这段代码的改写方案，switch出场： /** * 按钮点击事件 * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消 */ const onButtonClick = (status)=&gt;{ switch (status){ case 1: sendLog(&apos;processing&apos;) jumpTo(&apos;IndexPage&apos;) break case 2: case 3: sendLog(&apos;fail&apos;) jumpTo(&apos;FailPage&apos;) break case 4: sendLog(&apos;success&apos;) jumpTo(&apos;SuccessPage&apos;) break case 5: sendLog(&apos;cancel&apos;) jumpTo(&apos;CancelPage&apos;) break default: sendLog(&apos;other&apos;) jumpTo(&apos;Index&apos;) break } } 嗯，这样看起来比if/else清晰多了，细心的同学也发现了小技巧，case 2和case 3逻辑一样的时候，可以省去执行语句和break，则case 2的情况自动执行case 3的逻辑。 这时有同学会说，还有更简单的写法： const actions = { &apos;1&apos;: [&apos;processing&apos;,&apos;IndexPage&apos;], &apos;2&apos;: [&apos;fail&apos;,&apos;FailPage&apos;], &apos;3&apos;: [&apos;fail&apos;,&apos;FailPage&apos;], &apos;4&apos;: [&apos;success&apos;,&apos;SuccessPage&apos;], &apos;5&apos;: [&apos;cancel&apos;,&apos;CancelPage&apos;], &apos;default&apos;: [&apos;other&apos;,&apos;Index&apos;], } /** * 按钮点击事件 * @param {number} status 活动状态：1开团进行中 2开团失败 3 商品售罄 4 开团成功 5 系统取消 */ const onButtonClick = (status)=&gt;{ let action = actions[status] || actions[&apos;default&apos;], logName = action[0], pageName = action[1] sendLog(logName) jumpTo(pageName) } 上面代码确实看起来更清爽了，这种方法的聪明之处在于：将判断条件作为对象的属性名，将处理逻辑作为对象的属性值，在按钮点击的时候，通过对象属性查找的方式来进行逻辑判断，这种写法特别适合一元条件判断的情况。 是不是还有其他写法呢？有的： const actions = new Map([ [1, [&apos;processing&apos;,&apos;IndexPage&apos;]], [2, [&apos;fail&apos;,&apos;FailPage&apos;]], [3, [&apos;fail&apos;,&apos;FailPage&apos;]], [4, [&apos;success&apos;,&apos;SuccessPage&apos;]], [5, [&apos;cancel&apos;,&apos;CancelPage&apos;]], [&apos;default&apos;, [&apos;other&apos;,&apos;Index&apos;]] ]) /** * 按钮点击事件 * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消 */ const onButtonClick = (status)=&gt;{ let action = actions.get(status) || actions.get(&apos;default&apos;) sendLog(action[0]) jumpTo(action[1]) } 这样写用到了es6里的Map对象，是不是更爽了？Map对象和Object对象有什么区别呢？ 一个对象通常都有自己的原型，所以一个对象总有一个”prototype”键。 一个对象的键只能是字符串或者Symbols，但一个Map的键可以是任意值。 你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认。 我们需要把问题升级一下，以前按钮点击时候只需要判断status，现在还需要判断用户的身份： /** * 按钮点击事件 * @param {number} status 活动状态：1开团进行中 2开团失败 3 开团成功 4 商品售罄 5 有库存未开团 * @param {string} identity 身份标识：guest客态 master主态 */ const onButtonClick = (status,identity)=&gt;{ if(identity == &apos;guest&apos;){ if(status == 1){ //do sth }else if(status == 2){ //do sth }else if(status == 3){ //do sth }else if(status == 4){ //do sth }else if(status == 5){ //do sth }else { //do sth } }else if(identity == &apos;master&apos;) { if(status == 1){ //do sth }else if(status == 2){ //do sth }else if(status == 3){ //do sth }else if(status == 4){ //do sth }else if(status == 5){ //do sth }else { //do sth } } } 原谅我不写每个判断里的具体逻辑了，因为代码太冗长了。 原谅我又用了if/else，因为我看到很多人依然在用if/else写这种大段的逻辑判断。 从上面的例子我们可以看到，当你的逻辑升级为二元判断时，你的判断量会加倍，你的代码量也会加倍，这时怎么写更清爽呢？ const actions = new Map([ [&apos;guest_1&apos;, ()=&gt;{/*do sth*/}], [&apos;guest_2&apos;, ()=&gt;{/*do sth*/}], [&apos;guest_3&apos;, ()=&gt;{/*do sth*/}], [&apos;guest_4&apos;, ()=&gt;{/*do sth*/}], [&apos;guest_5&apos;, ()=&gt;{/*do sth*/}], [&apos;master_1&apos;, ()=&gt;{/*do sth*/}], [&apos;master_2&apos;, ()=&gt;{/*do sth*/}], [&apos;master_3&apos;, ()=&gt;{/*do sth*/}], [&apos;master_4&apos;, ()=&gt;{/*do sth*/}], [&apos;master_5&apos;, ()=&gt;{/*do sth*/}], [&apos;default&apos;, ()=&gt;{/*do sth*/}], ]) /** * 按钮点击事件 * @param {string} identity 身份标识：guest客态 master主态 * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 开团成功 4 商品售罄 5 有库存未开团 */ const onButtonClick = (identity,status)=&gt;{ let action = actions.get(`${identity}_${status}`) || actions.get(&apos;default&apos;) action.call(this) } 上述代码核心逻辑是：把两个条件拼接成字符串，并通过以条件拼接字符串作为键，以处理函数作为值的Map对象进行查找并执行，这种写法在多元条件判断时候尤其好用。 当然上述代码如果用Object对象来实现也是类似的： const actions = { &apos;guest_1&apos;:()=&gt;{/*do sth*/}, &apos;guest_2&apos;:()=&gt;{/*do sth*/}, //.... } const onButtonClick = (identity,status)=&gt;{ let action = actions[`${identity}_${status}`] || actions[&apos;default&apos;] action.call(this) } 如果有些同学觉得把查询条件拼成字符串有点别扭，那还有一种方案，就是用Map对象，以Object对象作为key： const actions = new Map([ [{identity:&apos;guest&apos;,status:1},()=&gt;{/*do sth*/}], [{identity:&apos;guest&apos;,status:2},()=&gt;{/*do sth*/}], //... ]) const onButtonClick = (identity,status)=&gt;{ let action = [...actions].filter(([key,value])=&gt;(key.identity == identity &amp;&amp; key.status == status)) action.forEach(([key,value])=&gt;value.call(this)) } 是不是又高级了一点点？ 这里也看出来Map与Object的区别，Map可以用任何类型的数据作为key。 我们现在再将难度升级一点点，假如guest情况下，status1-4的处理逻辑都一样怎么办，最差的情况是这样： const actions = new Map([ [{identity:&apos;guest&apos;,status:1},()=&gt;{/* functionA */}], [{identity:&apos;guest&apos;,status:2},()=&gt;{/* functionA */}], [{identity:&apos;guest&apos;,status:3},()=&gt;{/* functionA */}], [{identity:&apos;guest&apos;,status:4},()=&gt;{/* functionA */}], [{identity:&apos;guest&apos;,status:5},()=&gt;{/* functionB */}], //... ]) const actions = ()=&gt;{ const functionA = ()=&gt;{/*do sth*/} const functionB = ()=&gt;{/*do sth*/} return new Map([ [{identity:&apos;guest&apos;,status:1},functionA], [{identity:&apos;guest&apos;,status:2},functionA], [{identity:&apos;guest&apos;,status:3},functionA], [{identity:&apos;guest&apos;,status:4},functionA], [{identity:&apos;guest&apos;,status:5},functionB], //... ]) } const onButtonClick = (identity,status)=&gt;{ let action = [...actions()].filter(([key,value])=&gt;(key.identity == identity &amp;&amp; key.status == status)) action.forEach(([key,value])=&gt;value.call(this)) } 这样写已经能满足日常需求了，但认真一点讲，上面重写了4次functionA还是有点不爽，假如判断条件变得特别复杂，比如identity有3种状态，status有10种状态，那你需要定义30条处理逻辑，而往往这些逻辑里面很多都是相同的，这似乎也是笔者不想接受的，那可以这样实现: const actions = ()=&gt;{ const functionA = ()=&gt;{/*do sth*/} const functionB = ()=&gt;{/*do sth*/} return new Map([ [/^guest_[1-4]$/,functionA], [/^guest_5$/,functionB], //... ]) } const onButtonClick = (identity,status)=&gt;{ let action = [...actions()].filter(([key,value])=&gt;(key.test(`${identity}_${status}`))) action.forEach(([key,value])=&gt;value.call(this)) } 这里Map的优势更加凸显，可以用正则类型作为key了，这样就有了无限可能，假如需求变成，凡是guest情况都要发送一个日志埋点，不同status情况也需要单独的逻辑处理，那我们可以这样写: const actions = ()=&gt;{ const functionA = ()=&gt;{/*do sth*/} const functionB = ()=&gt;{/*do sth*/} const functionC = ()=&gt;{/*send log*/} return new Map([ [/^guest_[1-4]$/,functionA], [/^guest_5$/,functionB], [/^guest_.*$/,functionC], //... ]) } const onButtonClick = (identity,status)=&gt;{ let action = [...actions()].filter(([key,value])=&gt;(key.test(`${identity}_${status}`))) action.forEach(([key,value])=&gt;value.call(this)) } 也就是说利用数组循环的特性，符合正则条件的逻辑都会被执行，那就可以同时执行公共逻辑和单独逻辑，因为正则的存在，你可以打开想象力解锁更多的玩法，本文就不赘述了。 总结本文已经教你了8种逻辑判断写法，包括： if/else switch 一元判断时：存到Object里 一元判断时：存到Map里 多元判断时：将condition拼接成字符串存到Object里 多元判断时：将condition拼接成字符串存到Map里 多元判断时：将condition存为Object存到Map里 多元判断时：将condition写作正则存到Map里 至此，本文也将告一段落，愿你未来的人生里，不只是有if/else/switch。","categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://xinshani.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"}]},{"title":"JavaScript 开发者10种必备VS Code扩展","slug":"JavaScript 开发者10种必备VS Code扩展","date":"2018-11-08T02:14:45.000Z","updated":"2022-04-06T01:45:23.117Z","comments":true,"path":"p/68190613/","link":"","permalink":"https://xinshani.github.io/p/68190613/","excerpt":"","text":"Visual Studio Code 无疑是当今最流行的轻量级代码编辑器。 它确实从其他流行的代码编辑器（比如：Sublime Text 和 Atom）中借鉴了大量的功能和特性 。 然而，它的成功主要来自于其提供更好性能和稳定性的表现。 此外，它还提供了如代码智能提示（IntelliSense）等开发者非常需要的功能。而这些功能，曾经只在像 Eclipse 或者 Visual Studio 2017 这样的集成开发环境(IDE)中才可用。 VS Code 的强大无疑来自于它的 扩展市场（marketplace） 。由于有非常活跃的开源社区，VS Code 现在几乎支持所有的编程语言、框架和开发技术。对库或框架的支持有多种方式，主要包括针对该特定技术提供代码片段，语法突出显示，Emmet 以及智能提示（IntelliSense）功能。 代码片段扩展当您第一次安装 VS Code 时，它附带了几个 JavaScript 和 Typescript 的代码片段功能。在开始编写现代 JavaScript 之前，您需要一些额外的代码片段来帮助您快速编写重复的 ES6 / ES7 代码： VS Code JavaScript(ES6) snippets ：目前最流行的，迄今为止安装量超过 120 万。此扩展为 JavaScript ， TypeScript ，HTML，React和Vue扩展提供 ES6 语法支持。 JavaScript Snippet Pack：JavaScript 有用的代码片段集合。 Atom JavaScript Snippet：从 atom/language-javascript 扩展移植的JavaScript代码段。 JavaScript Snippets：一系列ES6片段。此扩展包含 Mocha，Jasmine和其他BDD测试框架的片段。 愚人码头注：另外你也可以根据自己的习惯创建代码片段，请参阅 如何在 Visual Studio Code 中创建代码片段 。 语法扩展VS Code 为 JavaScript 代码提供了非常好的语法高亮显示。 您可以通过安装主题来更改颜色。 但是，如果您想要增强代码的可读性，则需要语法高亮显示扩展。 以下是其中几个： JavaScript Atom Grammar：此扩展使用 Atom 编辑器中的 JavaScript 语法替换 Visual Studio Code 中的 JavaScript 语法。 Babel JavaScript：支持 ES201x JavaScript，React，FlowType和GraphQL代码的语法高亮显示。 DotENV：支持.env文件语法高亮显示。如果您正在使用Node，请使用方便。 代码检测扩展编写有效的 JavaScript 代码时，需要一个能够为所有团队成员强制执行特定编码风格的检测工具(linter)。 ESLint 是最受欢迎的，因为它支持许多编码风格，包括 Standard ，Google 和 Airbnb。 以下是 Visual Studio Code 最流行的 linter 插件： ESLint ：此扩展将 ESLint 集成到 VS Code 中。它是最受欢迎的 linter 扩展，迄今为止安装量超过670万。规则在 .eslintrc.json 中配置。 JSHint ：JSHint 的代码检查器扩展。在项目的根目录使用 .jshintrcfile 进行配置。 JavaScript Standard Style ：零配置和严格规则的检测工具。执行 StandardJS 规则。 JSLint ：JSLint的 linter 扩展。 如果您想了解可用的 检测工具(linter) 及 各自的优缺点，请查看我们对 JavaScript linting 工具的比较 。 Node 扩展每个 JavaScript 项目都需要至少一个 Node 包，除非你是一个喜欢艰苦工作的人。以下是一些 VS Code 扩展，可帮助您更轻松地使用 Node 模块。 npm ：使用 package.json 验证已安装的软件包。确保已安装的软件包版本号正确，高亮显示 package.json 中缺少的已安装软件包以及尚未安装的软件包。 Node.js Modules IntelliSense：自动补全 import 语句中的 JavaScript 和 TypeScript 模块。源码：vscode-node-module-intellisense Path IntelliSense ：它和 Node 其实并不相关，但你肯定需要对本地文件的智能提示，这个扩展将自动补全文件名。 Node exec ：允许您使用Node.js执行当前文件或您选择的代码。 View Node Package ：使用此扩展快速查看 Node 包源，允许您直接从 VS Code 打开 Node 包仓库库/文档。 Node Readme ：快速打开npm包文档。 Search node_modules ：此扩展允许您搜索 node_modules 文件夹，该文件夹不在默认的搜索范围内。源码：vscode-search-node-modules。 Import Cost ：显示导入的包的大小。源码：import-cost。 代码格式化扩展偶尔，您会发现自己格式化的代码并非以首选的编码风格编写。为了节省时间，您可以以下任何的 VS Code 扩展来快速格式化和重构现有代码： Beatufy ：一个支持 JavaScript，JSON，CSS 和 HTML 的 jsBeautifier(代码美化) 扩展。可以通过 .jsbeautifyrc 文件进行自定义。迄今为止最流行的格式化工具，安装量为 230 万次。 Prettier Code Formatter ：一个扩展，支持使用Prettier（一种固定代码格式化程序）格式化JavaScript，TypeScript和CSS。迄今已安装超过150万。 JS Refactor ：提供了许多用于重构 JavaScript 代码的实用程序和操作，例如提取变量/方法，将现有代码转换为使用箭头函数或模板字面量以及导出函数。 JavaScript Booster ：一个牛逼的代码重构工具。具有多种编码操作，例如将 var 转换为 const 或 let ，删除冗余的 else语句，以及合并声明和初始化。很大程度上受到WebStorm 的启发。源码：vscode-javascript-booster。 浏览器扩展除非你是在用 JavaScript 编写控制台程序，否则您很可能会在浏览器中执行 JavaScript 代码。 这意味着,您需要经常刷新页面来查看您所做的每次代码更新的效果。 这里有一些工具可以显着减少重复过程的开发时间，而不是每次都手动刷新浏览器： Debugger for Chrome ：在 Chrome 中轻松调试 JavaScript（通过在编辑器中设置断点）。源码：vscode-chrome-debug。 Live Server ：具有静态和动态页面的实时重新加载功能的本地开发服务器。源码：vscode-chrome-debugvscode-live-server。 Preview on Web Server ：提供web服务器和实时预览功能。 PHP Server ：对于测试仅需要在客户端运行的 JavaScript 代码非常有用。。 Rest Client ：您可以安装此工具以在编辑器内交互式运行HTTP 请求，而不是使用浏览器或 CURL 程序来测试 REST API 端点。 框架类扩展对于大多数项目，您需要一个合适的框架来构建代码并缩短开发时间。 VS Code 通过扩展支持大多数主流框架。 但是，仍然有许多已建立的框架尚未完全支持。 以下是一些提供重要功能的 VS Code 扩展。 Angular 6 ：提供 Angular 6 的代码片段。支持 Typescript，HTML，Angular Material ngRx，RxJS 和 Flex Layout。到目前为止，已安装了220多万个安装和 172 个 Angular 代码片段。 Angular v5 snippets ：为 TypeScript，RxJS，HTML 和 Docker 文件提供 Angular 代码片段。迄今为止已有 270多 万个安装量。 React Native/React/Redux snippets for es6/es7 ：为所有这些框架提供 ES6 / ES7 语法的片段。 React Native Tools ：为 React Native 框架提供智能提示，命令行工具和调试功能。 Vetur ：为Vue框架提供语法高亮，代码片段，Emmet，linting（代码检测），格式化，智能提示和调试支持。它附带了在 GitBook 上发布的使用文档 。 Ember ：为Ember提供命令支持和智能提示。安装后，所有 ember cli 命令都可以通过 VS Code 自己的命令行列表中使用。 Cordava Tools ：支持 Cordova 插件和 Ionic 框架。为基于 Cordova 的项目提供智能提示，调试和其他支持功能。 jQuery Code Snippets ：提供了超过130个jQuery的代码片段，使用 jq 前缀来激活。 测试类扩展测试是软件开发的关键环节，特别是对于处于生产阶段的项目。 您可以全面了解 JavaScript 的测试，并且你可以通过阅读我们的指南：JavaScript测试：单元测试 vs 功能测试 vs 集成测试 来获得更多不同类型的测试的信息。 Mocha sidebar ：为使用 Mocha 库进行测试的项目提供支持。此扩展可帮助您直接在代码上运行测试，并将错误信息以装饰器形式显示。 ES Mocha Snippets ：提供 ES6 语法的 Mocha 代码片段。这个插件的重点在于利用箭头函数，尽可能减少花括号的使用，保持代码的紧凑。可通过设置允许使用分号。 Jasmine Code Snippets ：针对Jasmine测试框架的代码片段。 Protractor Snippets ：Protractor 框架的端到端测试片段。支持 JavaScript 和 Typescript 。 Node TDD ：为Node和JavaScript项目的测试驱动开发提供支持。可以在更新源时触发自动测试构建。源码：node-tdd 。 还有一些非常棒的扩展我只是将下一批 VS Code 扩展归入到 “awesome” 类别中，因为它最能描述它们！ Quokka.js ：一个很棒的调试工具，为 JavaScript 代码提供快速原型操作。附带 优秀的文档。 Paste as JSON ：快速将 JSON 数据转换为 JavaScript 代码。源码：quick-type。 Code Metrics ：这是计算 JavaScript 和 TypeScript 代码复杂性的另一个很棒的扩展。源码：codemetrics 。 总结VS Code 的大量质量扩展使其成为 JavaScript 开发人员的热门选择。 有效地编写 JavaScript 代码从未如此简单。 诸如 ESLint 之类的扩展可以帮助您避免常见错误，而其他诸如 Debugger for Chrome 则可以帮助您更轻松地调试代码。 具有智能提示功能的 Node.js 扩展可帮助您正确导入模块，Live Server 和 REST client 等工具的可用性减少了您对外部工具的依赖，从而完成您的工作。 所有这些工具都使您的迭代过程变得更加容易。 我希望这些列表让你接触到新的 VS Code 扩展，对你的工作流程有帮助。","categories":[{"name":"工具","slug":"工具","permalink":"https://xinshani.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"VS Code","slug":"VS-Code","permalink":"https://xinshani.github.io/tags/VS-Code/"}]},{"title":"爬小程序源码","slug":"爬小程序源码","date":"2018-06-25T09:09:46.000Z","updated":"2022-04-06T01:45:23.123Z","comments":true,"path":"p/70c86dd0/","link":"","permalink":"https://xinshani.github.io/p/70c86dd0/","excerpt":"","text":"小程序在目前来看，依托着微信平台，有着很好的体验，个人觉得比web App好很多，目前代码包最大已经支持8M了，且类似vue开发风格，前端上手贼快。今天重点可不是介绍怎么做它，曾几何时有没有被其他小程序炫酷的功能震撼心灵，曾几何时有没有想爬一爬源码而不得的冲动，那么无论你出于是像我一样的借鉴参考学习，还是不法臆想，今天我们就来扒一下它。 一、万事开头难准备 node环境、git工具、一部root了的安卓手机或者模拟器 二、操作流程I、使用gitgit clone https://github.com/qwerty472123/wxappUnpacker.git II、在手机的微信中，随便打开一个小程序，记下你打开的当前是时间是几点III、用re管理器，进入到/data/data/com.tencent.mm/MicroMsg//appbrand/pkg/目录，并通过时间找到刚才的打开的小程序，就是一个后缀名为.wxapkg的文件，并放到d盘IV、进入到刚才git的项目中 //cd到项目目录，或者傻瓜式点进去 cd wxappUnpacker //安装依赖 npm install //特别的再安装如下几个 npm install esprima -g npm install css-tree -g npm install cssbeautify -g npm install vm2 -g npm install uglify-es -g npm install js-beautify -g //最后再执行 node wuWxapkg.js &lt;files…&gt; //files就是你的.wxapkg的文件路径 例如我git到的是d盘，那我就输入node .\\wuWxapkg.js D:\\_-317246217_18.wxapkgok,你会在.wxapkg的目录下发现一个文件夹了，直接用微信开发者工具进入，就可以看到项目效果了，然后你可以继续你的非法臆想了。notice:记得打开不检验合法域名的选项 你以为最后一段是结束语吗？错了，接下来，你们肯定会遇到一些莫名奇妙的问题，比如执行 node wuWxapkg.js ... 失败的问题，细心细心细心，你肯定有什么依赖没装，仔细检查，如果都装了看看反编译的.wxapkg目录有没有错，肯定有人不服，什么都对，但是node wuWxapkg.js ... 编译出来的文件和源小程序项目结构等完全不一样。对，这就是为什么有这一段的重点的重点，常规的开发我们确实可以拿到.wxapkg来反编译，但是如果用wepy，mpvue做的小程序就不行了。当年我也是超级脑残的认为如此简单的开发，为何要复杂的用wepy等，漫漫的人生路就是这么奇妙，岁月会来告诉，孩子，为了装X。没错附带一点点安全就是这么重要。历史告诉我们不要给坏人一点点的可乘之机","categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://xinshani.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"记12-23","slug":"记12-23","date":"2017-12-22T01:22:36.000Z","updated":"2022-04-06T01:45:23.123Z","comments":true,"path":"p/9c1f1b33/","link":"","permalink":"https://xinshani.github.io/p/9c1f1b33/","excerpt":"","text":"祝各位考研朋友，金榜题名。 你要知道，“找个心平气和的日子坐下来，坐着，抗拒种种情绪情绪，连续几小时。其间做题读书，间或发一下呆。开头一个星期有些艰难，之后会好些。据说三个星期连续做一件事可以养成一个习惯，然而人杰者如你，内心愈狂乱，愈有自制，七天够了。或者最重要的，是心底的那一点不甘，和对自己的信心。坚信不会就此碌碌一生，坚信自己值得更好的，坚信命运始终的垂青。并明白达到那永恒和安心的前景，靠的是自己这小小一双手。我们都在和自己打仗，要克服负面情绪、甚至是快乐的诱惑，可是，读书的时候，真的心里很安宁，很塌实，很久都没有这种感觉了，是因为过了太久的浮躁。”，这简直是一件非常不可思议的一件事件，到了我们这岁数见书就困，更不会有时间，所有很欣赏能把这样一件事做完的人。 和大多数的人一样，目前的生活是曾经努力的结果，这人啦，上了年纪就喜欢怀旧，念细节，多年之后再想起如今考研的岁月，搬砖都可能力量倍增。 还记得许多年前的春天，——又想起春天里了，看了遍mv，还是那个感觉，感谢曾今努力过的自己。明周六，加油，阳光明媚，适合加班。 我爱加班，加班使我快乐","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://xinshani.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[]},{"title":"使用WebSocket搭建聊天服务器","slug":"使用WebSocket搭建聊天服务器","date":"2017-12-10T10:40:04.000Z","updated":"2022-04-06T01:45:23.121Z","comments":true,"path":"p/1f110b58/","link":"","permalink":"https://xinshani.github.io/p/1f110b58/","excerpt":"","text":"hello，今天我们来玩一下WebSocket，一个神奇的协议，我们现在的需求是这样，我需要实现一个聊天，理所当然需要搭建一个服务器，这个环境用Node来搭建，前端可以采用ajax来提交需要发送的数据，似乎没毛病哈，但client A 发送的数据，client B怎么及时接收呢？轮询是吧，可以。但有个更优雅的解决方案。 http 对于每个开发人员来说都再熟悉不过，客户端发起请求，服务器响应，似乎很合理。WebSocket就是来打破这种合理的，服务器也可以主动的，这样一个优雅的方案就诞生了。服务器主动向客户端发消息，把clilent A的数据，主动给client B、C、D等等。 1、搭建node环境a.如node环境没装的请自行安装 b.在本地建一个文件夹,如20171210 c/1.你可以npm init ，在npm install espress --save和 npm install --save socket.io c/2.新建一个package.json，导入如下代码，再npm install notice：一定要在20171210 目录下打开终端输入 { “name”: “chat”, “version”: “0.0.1”, “description”: “my chat”, “dependencies”: { “express”: “^4.15.2”, “socket.io”: “^2.0.4” } } 2、创建node脚本新建server.js文件，内容如下，之后使用node server.js运行脚本var app = require(‘express’)(); var http = require(‘http’).Server(app); var io = require(‘socket.io’)(http); app.get(‘/‘, function(req, res){ //__dirname 是node的全局变量global的属性（类似浏览器的window），表当前模块的文件夹名称 res.sendFile(__dirname + ‘/index.html’);//默认打开index.html文件，暂并没有创建该文件，所以打开localhost:3001会报错 }); //建立连接 io.on(‘connection’, function(socket){ //监听客户端的message事件 socket.on(‘message’, function(msg){ //把client A发来的数据，给更多的client,客户端要监听这个reversion 才可拿到服务器发来的消息 io.emit(‘reversion’, msg); }); }); //websocket 也是建立再http基础上的，并监听3001端口 http.listen(3001, function(){ console.log(‘监听成功’); }); 3、客户端（浏览器）需要做的操作此处只展示script里的部分，切为演示效果把需要发送的内容写死，前端效果请自行编写，可在当前目录都建几个html，相当于每一个html就是一个用户，每一个用户都会送到消息，当然也可以发送不同的消息//引入socket脚本 $(function () { //实例化socket var socket = io(); //前端提交， $(‘form’).submit(function(){ //后台已经监听了message事件，把字符串发送给后台 socket.emit(‘message’, ‘我是要发送的数据’); }); //客户点监听reversion事件，msg为回调数据（刚发送的数据） socket.on(‘reversion’, function(msg){ console.log(‘服务器发来的数据是:’+mes); }); }); 4、效果具体效果，有时间会在此处展示出来，不早了，收拾收拾回家，明周一正常工作日，加油 项目地址https://github.com/xinshani/websocket–demo","categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"},{"name":"Node","slug":"Node","permalink":"https://xinshani.github.io/tags/Node/"}]},{"title":"一个没有包袱的框架 Vue","slug":"一个没有包袱的框架 Vue","date":"2017-08-13T09:51:16.000Z","updated":"2022-04-06T01:45:23.121Z","comments":true,"path":"p/3212f87e/","link":"","permalink":"https://xinshani.github.io/p/3212f87e/","excerpt":"","text":"notice为不坑新老朋友，现vue-cli已更新到3.0并改名为@vue/cli,前段时间试了下，臃肿度好了很多,vue语法没有改变，只是脚手架工具优化了，所有本文章依然有效，还有支持图形化界面vue ui，详见@vue/cli 老规矩了得先说，聊一个五毛钱的天，两个月过去了，生活真的很神奇，当初想出武汉看看，于是上手了react，第一份工作是靠它来的，后来又入了vue，第二份工作也是靠它，再后来靠vue入了weex。在SPA这条路上真是操碎了心，vue的star也越来越多（63.2k），快追上react(73.4k)了。vue后来居上，可以说集了angular和react的优势，且没有历史包袱，好用好学，vue的扩展也非常丰富，官方主要维护的是vue，vux，vue-router。就我目前的经验分享一点vue的使用，如果要看一些vue的说明等等，官网是最好的选择。vue官网。开始之前，希望先去官网学习一下。 1.vue的安装万事开头难，这个真没啥好说的，还是老三样，node，npm， vue-cli(官方脚手架，集成webpack及常用loader) 2.vue的文件单组件.vue可以看github上的任何一个小demo，每个.vue的单文件组件，最后通过webpack的vue-loader可以配套打包。 &lt;!-- hello.vue –&gt; 我是组件 hello.vue //我是子组件 import aCompont from ‘a-compont.vue’ / 在这个hello.vue组件中，引入了一个a-compont.vue的组件，我们叫这个引入的组件为子组件，这个hello.vue为父组件 *1.引入之后先在父组件中注册 *2.以标签的形式写入template中，（别和HTML重名） */ export default { created () { //最常用的生命周期函数，当hello.vue创建完成(数据初始化之后，可以看官方描述)之后调用 this.doSomething(); //调用methods 中的方法 console.log(this.dataA); //通过this 可以访问data中的数据 }, data () {//data 可以是一个对象，可以是一个函数， return { // return 的作用是 当hello.vue这个组件复用的时候，如果在其中一个组件中的data 改变，不会影响到其他的组件中的data isShow: false, dataA: ‘我是字符串’, dataB: [{str= ‘a’},{str= ‘b’}] } }, componts：{ “aCompont”: aCompont, //引入之后的第一步就是注册这个组件 aCompont, // 键值对一样的时候，可以这么简写 }, methods:{ // hello.vue中的方法，可以在生命周期函数中调用，或者在template 中的事件调用 doSomething () { … } } } 3.指令v-指令是写在html中的，也是就是template中，众多的指令中，唯独爱v-for，给前端交互带来太大的作用了。接着上面的js部分说，还有众多的指令上官网查看吧。 &lt;!-- hello.vue –&gt; / \\v-bnid 可以简写成 : */ //把data中的 数据绑定到input的value中。 { {dataA}} // 插值 { {item.str}} 现在不显示 … 4.事件事件在是vue的核心，比如在子组件和父组件通讯的时，若不借助其他，事件是必须的。 &lt;!-- hello.vue –&gt; /在html写事件的事件的时候可以用 v-on: ,也可以简写成@ 自定义事件emit，下面的逻辑是: 在子组件中定义一个事件，触发事件的时候，执行父组件中的自定义事件。 在父组件中定义自定义事件，并接受子组件传过来的数据。 */ //调用methods 里面的方法 … //自定义事件的用法 自定义事件： 1、在父组件app.vue里面引入子组件： …… import componentA from ‘./components/a.vue’ export default { components: {componentA:componentA }, methods: { comeMyEvent (param) { alert(‘当子组件中的事件触发时，会弹出来’) console.log(param) //这就是子组件中传过来的data.hello } } } …… 2、在子组件a.vue中编辑子组件。并且把data的hello传到父组件中 …… emit export default { data () { return { hello: ‘我是引入的组件’ } }, methods: { emitEvent () { //emitEvent 触发时， alert(); this.$emit(‘my-event’,this.hello) //监听 my-event 事件 } } } ……","categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://xinshani.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"},{"name":"VUE","slug":"VUE","permalink":"https://xinshani.github.io/tags/VUE/"}]},{"title":"React 入门实例教程","slug":"React 入门实例教程","date":"2017-05-12T03:58:48.000Z","updated":"2022-04-06T01:45:23.117Z","comments":true,"path":"p/1f59c223/","link":"","permalink":"https://xinshani.github.io/p/1f59c223/","excerpt":"","text":"几个月前，就开始耕耘react了。网上七七八八的教程老又杂，包括一些react的一些书籍也都是很早之前的。虽说一些原理还是相通的，但是不建议新手学习(特别是0.14之前的版本简直是误人子弟)。踩了太多的坑了，拿出来先分享一下，我们学习之前，其实可以来分析分析react或者说框架什么的。 首先，作为一个新时代的web前端高级工程师，记住是高级。那么多的框架和技术，学习是很有必要的，但是别跟风学。所有的框架都是为了简化开发难度的，也不用害怕。并且像angular、react、vue。被说成是mvc、v、mvvm什么乱七八糟的想怎么定义都行，一句话解释就是为了简化DOM操作。其中，react并不是一套完整的解决方案，以至于常在口边念叨的react其实是一套全家桶，建厂生产加工包装销售的一条龙服务。react、redux\\flux、react-dom、jsx\\babel、react-router、webpack、Sass\\Less、ES6\\ES5、node\\npm等一些列解决方案来构建react app。 这么多东西，我们当然是需要些基础的，但是呢，没必要一个个学，如果你不知道是否需要它，那就是不需要它，这里我们用的技术全都是最新的。 第一、react参考资源：react官网创建一个虚拟DOM有很多种方法，但是我们结合es6最新的语法class，所以如果我们自己在网上看到的些，都是官方不推荐的做法，比如createElement()、React.createClass()、更有甚者用React.render()输出虚拟DOM到页面，这都是0.14之前的版本，太老了会误导我们。0.14的版本把react分成了react和react-dom两个部分 //ES6的语法导入react import React from “react”; //React.Component这个React内置的构造函数上继承一些有用的方法。比如钩子函数等。 //class里面的方法与方法之间千万别加 ‘ , ’ class App extends React.Component { //render方法是必须的 render() { //为了避免JavaScript自动添加分号的机制给我们带来麻烦，在换行的JSX外面添加一对小括号 return ( …JSX… ) } } //以下写法和上面是等价的 import React,{ Component } from “react”; class App extends Component { render() { return ( …JSX… ) } } react的生命周期，创建期getInitialState初始化状态、getDefaultProp设置默认属性在es6里面都就没必要这么麻烦了， //初始化默认状态 class Counter extends Component { //构造函数，组件实例化的时候会首先执行。 constructor(props) { // ES6中类的constructor函数可以通过super访问其父类的构造函数 super(props); this.state = { count: props.initialCount }; } render() { // … } } //设置默认属性 Counter.defaultProps = { initialCount: 0 }; 第二、jsx/babel使用jsx很容易就创建虚拟DOM，babel是可以把es6转成es5，编译jsx，甚至可以吧es6转成es7。官方推荐的语法糖。 import React,{ Component } from “react”; class App extends Component { render() { var class=’box’; return ( //jsx只有一个顶级元素,所以在两个div最外面再套一个div。 //HTML怎么写，jsx就怎么写。 //{} 里面写js {/这里是注释/} 1 2 ) } } 第四、路由现在官方同时在维护两个版本，2.0和4.0，强烈推荐完整看一遍阮一峰的博客和练一遍官方的14个demo，很好很详细，全过一遍，包教不包会。阮一峰react-router教程官方router_demo 第五、npm/es6这些预备知识还是需要知道一些的，可以参考我的其他文章或者或者在网上学习下其他人发的帖ES6入门npm 文档 搭建一个react app我们使用官方工具 create-creat-app 来快速搭建一个app，我们调用豆瓣api，项目地址 demo_douban全局安装npm install -g create-react-app创建项目create-react-app demo_douban进入项目cd demo_douban进入开发模式npm startsrc 文件下加一个文件夹叫做config，把豆瓣api的信息都放在里面。conponents 文件下都是我们需要的组件 这一个项目虽然小，但是可以说明很多问题，足够入门的了。","categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://xinshani.github.io/tags/ES6/"},{"name":"javascript","slug":"javascript","permalink":"https://xinshani.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://xinshani.github.io/tags/React/"}]},{"title":"重梳JavaScript原型链(二)","slug":"重梳JavaScript原型链(二)","date":"2017-05-01T03:07:55.000Z","updated":"2022-04-06T01:45:23.124Z","comments":true,"path":"p/191ce7a9/","link":"","permalink":"https://xinshani.github.io/p/191ce7a9/","excerpt":"","text":"之前呀，得我助提醒，在`prototype`应该说得详细些，之前我们说，每创建一个新函数，该函数就会有个prototype属性指向其原型对象。并且该函数的constructor属性就是来自prototype原型对象上的。例如： function Person (){ this.name=&apos;xinshan&apos;; } var person1= new Person(); /* 在这里为了看清prototype。我们规定： prototype 是实例对象perosn1的原型对象； prototype 是构造函数Person的原型属性； prototype 代替某些浏览器支持的\\_\\_proto\\_\\_； */ /* 那么以下就是prototype的详细说明了: 1、构造函数 Person的prototype原型属性和实例对象prototype原型对象指向是一样的。 2、实例对象 person1的constructor属性其实在其prototype原型对象上,constructor又指回到构造函数Person。 3、如果再实例化出 person2实例对象，以上观点依然成立，并且以上观点最主要是为了说明 */ /*实例对象在访问某一个属性的时候 * 1.首先会在当前对象中查找该属性， * 2.如果没有找到，会在构造方法里面查找 * 3.如果还没有找到，会在构造函数的 prototype 属性中查找 */到这里如果谈实际工作需求的话，已经够了。博主不才，目前接触过最大的框架arcgis for javascript(92m)就是基于此设计的，明白其原理，在学习和工作中才能应万变。 在JavaScript中，实现继承的最主要的方式的就是通过原型链。一个引用类型继承另一个引用类型的属性和方法。 function Oneobj(){ this.name=’xin’; } function Twoobj(){ this.age=18; } var oneObj = new Oneobj(); var twoObj = new Twoobj(); twoObj.prototype=new Oneobj(); //浏览器中请换成__proto__ alert(rwoObj.name) //‘xin’ 这样我们就完成了一个继承了。深入了解继承的路还有，有兴趣可以再看看。","categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"}]},{"title":"重梳javascript原型链(一)","slug":"重梳javascript原型链(一)","date":"2017-04-26T04:00:48.000Z","updated":"2022-04-06T01:45:23.124Z","comments":true,"path":"p/5207d2ba/","link":"","permalink":"https://xinshani.github.io/p/5207d2ba/","excerpt":"","text":"这有个故事。为什么所有的引用类型的实例对象都有toString()、valueOf()这两个方法？(引用类型指Object、Array、Function等)，这一定是个悲伤的故事，故事还得从很久以前说起，带着这个疑问，进入到这个故事。 首先什么都不用思考，得明白一件很绝对的事且任何时候都不能忘： 所有的对象都继承Object 所有的函数，只要是new 出来的就是构造函数 ok，首先我们得知道怎么去创建一个对象：//最简单创建对象的方式 var person = new Object(); person.name=’xin’; person.age=’18’; person.run=function(){ console.log(‘飞快’); } //还可以用对象字面量语法： var person={ name:’xin’, age:’18’, run:function(){ console.log(‘飞快’); } } //对象就相当于一个人，人是有属性的，比如name。还有方法,比如run。 //好了，已经创建完成了，好的开始是成功的一半。对象也出来了，person也有toString()的方法，我们的问题好像也该有答案了。可聪明的人类绝不止步于此，我要创建很多很多的对象，那不得把我写死。所以又出现了一种工厂模式（虽然ECMAScript没有类的概念），这个工厂模式，就可以看成类，它就是为了创造一个个对象的。 工程模式，工厂模式中你不用去管这个类是怎么创造的，相当于你早上去买面，给钱拿面就好，不用管这面怎么做出来的。（理解这个，对理解很抽象的面向对象很有帮助） function Person (name,age){ var o =new Object(); o.name=name; o.age=age; return o; } var person1=Person(‘xin’,18); //实例化两个对象 var person2=Person(‘zhang’,19);按照故事情节发展，工程模式肯定是有不足的。对，它创造出来的对象是什么类型呢？（确实是Object，但你知道为什么是Object吗？） 构造函数，构造函数里面有个constructor属性最初就是来识别对象类型的。 function Person (name,age){ this.name=name; //this指向的是实例对象。如果window下调用，可以用apply来改变this指 this.age=age; //向window的问题。 this.say=function(){ console.log(this); } } var person1=new Person(‘xin’,18); var person2=new Person(‘zhang’,19); alert(person1.constructor==Person); //true; alert(person1 instanceof Person); //true不过要说检测对象类型还是instanceof更靠谱些，因为它可以检测对象的原型链。并且构造函数也是有问题的，每实例化一个对象，是需要占用内存的且作用域不同，就算实例化对象之间有同一个属性方法。所以不同实例上的同名属性方法是不相等的。 原型模式，每个函数都有一个prototype的属性，它指向一个原型对象。在这个对象上的属性方法可以共享给实例对象的。 function Person (){} Person.prototype.name=’xin’; Person.prototype.age=’18’; Person.prototype.say=function(){ console.log(this) } var person1 = new Person(); var person2 = new Person(); alert(person1.say==person2.say);//true; /在访问某一个属性的时候 1.首先会在当前对象中查找该属性， 2.如果没有找到，会在构造方法里面查找 3.如果还没有找到，会在构造函数的 prototype 属性中查找 */ //原型模式下name、age、say是相同的都属于一个原型对象；好比两个孩子没钱，去找各自爸爸要，老爸也没有，但是他们有个共同的爷爷，在爷爷那拿到钱。 其实这里大概已经解释了，为什么所有的实例化对象都有toString()、valueOf()方法了。实例对象是没有，它们会去构造方法中找，构造方法没有，就去原型对象中找，原型对象没有，他们就到原型对象的原型对象中找，一直找到Object。（原型链的终点是null） 下期更精彩，详细说说prototype和继承。","categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"}]},{"title":"有感于我那糟糕透了的记性。","slug":"有感于我那糟糕透了的记性。","date":"2017-04-20T08:11:55.000Z","updated":"2022-04-06T01:45:23.123Z","comments":true,"path":"p/23942d89/","link":"","permalink":"https://xinshani.github.io/p/23942d89/","excerpt":"","text":"这两天闲下来，改改bug之余，翻了翻之前的原生JS，看了看jq，又跑去瞧了瞧CSS3，看着以前写的些特效，现在真是忘的忘、丢的丢。很多都记不得了，所幸的是翻开再温习运粮下下，真佩服当年年轻的模样呀。4个月前，啃了很久的arcgis for javascript 被忘得两眼懵半天，客户提的些新要求磨磨打打蹭了一天时间才搞完。刷知乎看到别人面试题里面提问为什么要写!doctype，使劲想了想，忘了，而后使劲拍了下头，不就是个声明嘛，再想了想，可能是这个公司没打算招人，这个问题的性质和人为什么要用腿走路、编程为什么要用电脑、你为什么是个男的、她为什么又是个女的一样一样的，问些有意义价值的问题不好嘛，我倒是觉得面试的最有效且最能体现水平是 face to face，慢下来，谈嘛。 时常我就在想，为什么某些皮皮虾可以记住那么多，一会JS写的飞起，一会java玩得很溜。他们是怎么记住那么多的呢，每个人的答案都是个猜测，但猜测的意思是一样的，别人牛嘛。 审了审文章，不知道说了些什么乱七八糟的，也不知道想说什么，想哪写哪了，自己的leggod，想咋地咋地，说不定过两天再翻的时候发现前两天的自己好傻逼，就删了。But , who cares","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://xinshani.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[]},{"title":"css预处理语言-SASS","slug":"css预处理语言-SASS","date":"2017-04-17T01:34:52.000Z","updated":"2022-04-06T01:45:23.118Z","comments":true,"path":"p/dcbdbda8/","link":"","permalink":"https://xinshani.github.io/p/dcbdbda8/","excerpt":"","text":"孩童们，还记得当年玩CSS的时候，特别是CSS3的时候，那真是，大伟哥都心痛得无法呼吸。 周末玩了下SASS，怎么说呢，更有趣吧。我不确定这篇文章会教会些什么技术，那也不是我的目的。更多我写东西，是想表达下在自己在接触些东西的时候，是怎么想的怎么做的，是一些思路、一些理解、一些分享。记性不好，但文字可以使我迅速的想起来。 SASS呢，由Ruby编码，就是预编译的CSS，直白点就是使用SASS之后会编译成CSS，和传统的CSS在效果上一点区别都没有。所以我们是可以很友好的体验的。另外对于为什么要用SASS，而不直接用css，其实网上说法是SASS可以减少css的复用。记得当年写页面，css真的很多很多重复的，一个页面大几百行。使用SASS是需要安装Ruby的，但是学学玩玩嘛，推荐上sassmeister(记得挂SSR)，直接就可以体验到了。所以我就不写什么安装、编译风格之类的随处都可以百度到的傻瓜操作。 编写第一个SASS样式和SCSS样式：//SASS写法： .myClass :color red :background-color blue //SCSS写法 .myClass { color: red; background-color: blue; } //SCSS是SASS的一种语法，完美支持CSS3 //使用compressed风格编译出来，压缩风格，所有的css样式都再一行上 .myClass{color:red;background-color:blue} 变量：$var:2px;$top:left; .myClass { margin : $var; //属性值可直接用 padding - #{ $top } : $var; //属性要用到#{} text-indent : $var*2; //可运算 } //编译之后 .myClass{margin:2px;padding-left:2px;text-indent:4px} 嵌套：/选择器嵌套：/ $color:red; div{ span{ color:$color; } } //编译之后 div span{color:red} /属性嵌套/ $px:10px; div{ margin:{ //一定要加上 : left:$px/2; } } //编译之后 div{margin-left:5px} /嵌套使用伪类/ $px:10px; div{ &amp;:hover{ //&amp; 表示父元素 margin:{ left:$px/2; } } } //编译后 div:hover{margin-left:5px} 注释：/分两种单行和多行/ ‘ // ’ 单行 ‘ /*/ ’ 多行,编译之后会显示再css中，压缩模式不会保留 ‘ /！ */ ’ 多行，编译之后会显示再css中，压缩模式也会保留 继承：.error { border: 1px #f00; background-color: #fdd; } .seriousError { @extend .error; //@extend 继承error的样式 border-width: 3px; } //编译后 .error, .seriousError { border: 1px #f00; background-color: #fdd; } .seriousError { border-width: 3px; } mixin：//需要注意mixin的顺序，从上往下执行； @mixin clearfix { display: inline-block; &amp;:after { //&amp;表示父级 content: “.”; display: block; height: 0; clear: both; visibility: hidden; } html &amp; { height: 1px } //&amp;表示父级 } .page-title { padding: 4px; margin-top: 10px; @include clearfix; //@include 可以调用@mixin } //编译之后 .page-title { padding: 4px; margin-top: 10px; display: inline-block; } .page-title:after { content: “.”; display: block; height: 0; clear: both; visibility: hidden; } html .page-title { height: 1px; } 颜色函数：.title { color:lighten(red, 10%); //HSL 函数，色调高亮什么的。最后一个参数是透明度 color:darken(#fff, 20); //HSL 函数，头疼。。 color:rgb(24,255,255); //标准的RGB颜色，把10进制转成16进制。我还是用吸管吸，头疼。 background: rgba(0,0,0, 0.5); } //编译后 .title { color: #ff3333; color: #cccccc; color: #18ffff; background: rgba(0, 0, 0, 0.5); } 插入文件：//如果插入scss @import “path/filename.scss”; //如果插入css文件 @import “style.css”; 高级语法(玩过js的再看这个那都不是事)：1.条件语句 $type: a; p { @if $type == d { color: blue; } @else if $type == b { color: red; } @else if $type == c { color: green; } @else { color: black; } } //编译之后 p{color:black} 2.循环 //for循环 @for $i from 1 through 3 { .class#{$i} { width: 2em * $i; } } //编译后 .class1{width:2em}.class2{width:4em}.class3{width:6em} 3.@each 循环 和for 有点像 @each $n in a,b,c,d{ .#{ $n }{ background-image:url(‘image/#{$n}’); } } //编译后 .a{background-image:url(“image/a”)}.b{background-image:url(“image/b”)}.c{background-image:url(“image/c”)}.d{background-image:url(“image/d”)} 4.@while循环 $n:6; @while $n&gt;2{ .class#{$n}{ color:blue; }; $n:$n - 1; } //编译后 .class6{color:blue}.class5{color:blue}.class4{color:blue}.class3{color:blue} 5.@function函数 @function fn($n){ //声明函数 @return $n //返回值 } .class{ color:fn(red); //调用fn } //编译后 .class{color:red} 其实我发现，SASS相对于JS这些那是非常简单的。声明变量用$；关键字前面加上@；&amp;表示父选择器；注释一般都通用，再就是注意下#{}怎么用；一些计算、判断等语法，SASS就够了","categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://xinshani.github.io/tags/CSS/"}]},{"title":"OpenLayers缓冲分析—重难点","slug":"openlayers-e7-bc-93-e5-86-b2-e5-88-86-e6-9e-90-e9-87-8d-e9-9a-be-e7-82-b9","date":"2017-04-06T07:28:58.000Z","updated":"2022-04-06T01:45:23.119Z","comments":true,"path":"p/f0fc0c61/","link":"","permalink":"https://xinshani.github.io/p/f0fc0c61/","excerpt":"","text":"哇，好久没有更博了，项目上临时接了个北京奥体中心的管线项目，折腾了好几个星期，加上清明小长假，一晃就到了4月份了。其实在此期间我也没闲着，在皮皮虾大神的帮助下，我也碰了碰react，下次，说不定可以来个react的入门指导，一定是最通俗易懂的~~~ :oops: 今天还是来点不一样的，缓冲查询，这个就很刺激了。 或许前路永夜,即便如此我也要前进,因为星光即使微弱也会为我照亮前路 ——四月是你的谎言 缓冲查询有三点要素： distance 俗称缓冲距离；geometry 缓冲点；success 请求来的要素； 在执行查询前，我们应该为这次ajax请求准备条件，确定我们要查询的url、点和距离，例如：var geometry=JSON.stringify({//构造这个点，坐标传给x，y； “geometryType” : “esriGeometryPoint”, “geometries” : [{“x” : x, “y” : y}] }) var distance= $(‘.selectval’).val();//我取的是用户输入的value值 var url=window.cfg.buffer;//服务地址 之后我们就可以发出一个ajax请求了：$.ajax({ url:url, type : “post”, dataType:’jsonp’, data:{ inSR : “2361”, outSR : “2361”,//这个和上面那个都是空间坐标系 geometries:geometry,//之前已经用JSON。stringify转成了字符串了 distances : distance, f : “json” }, success:onSuccess, error:function(){ $.alert(“查询失败”,null); } }) onSuccess里面还需要发送一个ajax，这个查询是查在缓冲区范围的点要素（地名地址） var onSuccess=function(xhr){ console.log(xhr) // 根据所返回的范围进行查询 var data={ where : “NAME like”+” ‘ % “+val+” % ‘ “,//SQL语句 f:”json”, outFields:”*”,//所有字段 geometry:JSON.stringify(xhr.geometries[0]),//在缓冲区查询 geometryType:’esriGeometryPolygon’ } if(data.features.length==0){ $.alert(“没有查询到数据，请修改查询范围或内容”,null);return false;} // 将查询出的范围转换成ol格式,不然arcgis的服务是不能在openlayers上用的。 var olgeometrys = geometryArcToOl(xhr.geometries[0], “esriGeometryPolygon”); //高亮图层，其实就是在一个vector图层上添加要素。这里我把它封装成了一个函数。 kqMap.drawGeometryToDefineLayer(vectorLayer,olgeometrys,true); xhr.geometries[0].geometryType = ‘esriGeometryPolygon’; } 效果图请到博客园观看，传奇上帝博客园","categories":[{"name":"WebGis","slug":"WebGis","permalink":"https://xinshani.github.io/categories/WebGis/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"},{"name":"OpenLayers","slug":"OpenLayers","permalink":"https://xinshani.github.io/tags/OpenLayers/"}]},{"title":"package.json详解","slug":"package-json-e8-af-a6-e8-a7-a3","date":"2017-03-07T02:06:45.000Z","updated":"2022-04-06T01:45:23.120Z","comments":true,"path":"p/649b70a3/","link":"","permalink":"https://xinshani.github.io/p/649b70a3/","excerpt":"","text":"之前在github上看到有人翻译了package.json；很详细，特意转载来： package.json","categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"}]},{"title":"ES6","slug":"es6","date":"2017-03-02T06:55:37.000Z","updated":"2022-04-06T01:45:23.118Z","comments":true,"path":"p/d73c0d37/","link":"","permalink":"https://xinshani.github.io/p/d73c0d37/","excerpt":"","text":"ES6就是ECMAscript2015，一个新的语法。ECMAScript这啥那啥的发展史就不介绍了，（介绍也是去百度，何必呢！还不如自个度去。）只希望我们下次去与外人谈笑风生的时候，别看见ECMAScript就别懵了，或者某些人特意很喜欢非常爱装X，非得带个ES5、ES6什么的，显得很牛X的样子。其实呢，我们一般见到的js语法都是来源于ECMAscript 262，对原生JS语法我们可谓是非常熟悉了，可以说现在的ES6也是基于262的拓展。要做的事情是一样的，只是它有些新语法，简单好用，当然兼容性嘛，惨不忍睹，所以我推荐大家练习就用node命令行吧，简单好用； [**浏览器兼容性测试**](http://ruanyf.github.io/es-checker/) 所以还是老样子，我不喜欢谈理论，谈原理，不管是啥，会用才是我们的目的。 飞机票传送至博客园：[ES6,ES6,ES6](http://www.cnblogs.com/leggod/p/6490683.html)","categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://xinshani.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"}]},{"title":"学5分钟的，git!","slug":"学5分钟的，git","date":"2017-02-24T00:14:08.000Z","updated":"2022-04-06T01:45:23.122Z","comments":true,"path":"p/8a8b3708/","link":"","permalink":"https://xinshani.github.io/p/8a8b3708/","excerpt":"","text":"哈喽喽喽！本打算上星期就发的，可是呢，生性好玩~~~懂得懂得。罐头是在1810年发明出来的。可开罐器却在1858年才被发明出来。重要的东西有时也会迟来一步。无论爱情还是生活。好了，聊了5毛钱的了，开始上干货了。 最近阿里老是给我发消息，说丢包丢包，好吧，请传送至博客园， 戳我","categories":[{"name":"工具","slug":"工具","permalink":"https://xinshani.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"git","slug":"git","permalink":"https://xinshani.github.io/tags/git/"}]},{"title":"OpenLayers.Map的一些特殊事件","slug":"openlayers-map-e7-9a-84-e4-b8-80-e4-ba-9b-e7-89-b9-e6-ae-8a-e4-ba-8b-e4-bb-b6","date":"2017-02-04T09:05:07.000Z","updated":"2022-04-06T01:45:23.119Z","comments":true,"path":"p/d32be1bd/","link":"","permalink":"https://xinshani.github.io/p/d32be1bd/","excerpt":"","text":"嗨过完年，搞事情了，无意中发现了一些，在文档中，见不到的事件，特此记录下下。 传奇上帝博客园","categories":[{"name":"WebGis","slug":"WebGis","permalink":"https://xinshani.github.io/categories/WebGis/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"},{"name":"OpenLayers","slug":"OpenLayers","permalink":"https://xinshani.github.io/tags/OpenLayers/"}]},{"title":"ajax之后，你不知道的事","slug":"ajax之后，你不知道的事","date":"2017-01-18T09:12:11.000Z","updated":"2022-04-06T01:45:23.118Z","comments":true,"path":"p/2a13f03c/","link":"","permalink":"https://xinshani.github.io/p/2a13f03c/","excerpt":"","text":"年前的最后一篇文章了，看字哪里够呢，所以准备了很多图，还有最爱的代码； 祝一起成长的小伙伴的新春快乐哟，来年我们再一起互相伤害。 传送门戳我","categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"},{"name":"OpenLayers","slug":"OpenLayers","permalink":"https://xinshani.github.io/tags/OpenLayers/"}]},{"title":"OpenLayers的一些常规操作","slug":"openlayers-e7-9a-84-e4-b8-80-e4-ba-9b-e5-b8-b8-e8-a7-84-e6-93-8d-e4-bd-9c","date":"2017-01-11T03:21:15.000Z","updated":"2022-04-06T01:45:23.119Z","comments":true,"path":"p/d042ca09/","link":"","permalink":"https://xinshani.github.io/p/d042ca09/","excerpt":"","text":"最近忙于一些项目验收，之前准备了好几篇文章，都没来得及发，今天来点不一样的，OpenLayers，看到网上大多数都很敷衍，明明简单的、明了的却写的弯弯绕绕，想说不想说的样子，呵呵！！！直接上干货，简单明了1.map因为我这里的服务都是ArcGIS发布的，所以这的layer我会用ArcGIS93Rest；map = new OpenLayers.Map(“myDiv”,options);var layer=new OpenLayers.Layer.ArcGIS93Rest(“xzq”, “http://192.168.1.114:6080/arcgis/rest/services/epyzt/JCC_EPXZQ/MapServer/export&quot;, {layers:”0”})map.addLayer(layer) 这里要注意的的是arcgis的服务最后要加上export；字符串的option可以随便写，但一定要有意义。这样你的后面的项目越大，内容越多的时候，才不至于把自己绕进去。 上面我留了一个opions没有定义。options是一个对象，这个options的内容实在是太多了。我一般只会在定义一下初始化map的一些范围 2.optionsvar options={ displayProjection:”2361”, resolutions:[ 78271.66821448227, 39135.83675440268, 19567.91837587842, …… ], controls:[ new OpenLayers.Control.Navigation({}), new OpenLayers.Control.PanZoomBar({}), new OpenLayers.Control.LayerSwitcher({}), new OpenLayers.Control.MousePosition({}), new OpenLayers.Control.Permalink() ]} 像这样，就是在初始化的时候定义了一些东西，resolutions是递减的，值得注意的是controls，一个就是这种用法，还有一种就是初始化之后通过map.addControl()/addControls([])，加上去，后面我会说一些这样的方法。 3.放大、缩小function (param){ if(param==”in”){ map.zoomIn();//map要是全局 }else{ map.zoomOut(); }} 4.Draw这个思路掌握了，也就好说了。首先得加个Vector到地图上去，我们的每次draw都是再这个图层上操作的 funciton draw(){ lineLayer=new OpenLayers.Layer.Vector(“lineLayer”); map.addLayer(lineLayer); controlLineLayer=new OpenLayers.Control.DrawFeature( lineLayer, OpenLayers.Handler.Path, {…} ) map.addControl(controlLineLayer);} 5.measure这个是测量面积或者距离用的。 function measure (){ measureControls=new OpenLayers.Control.Measure( OpenLayers.Handler.Path,{ //测距就是Path，面积就是Polygon persist: true, immediate:true,//当该属性为true时，量算过程中时时显示结果，同时会触发 “measurepartial” 事件. autoActivate:true////本来该单独控制active()的，这演示就直接auto了； } ) measureControls.events.on({ //一个事件监听 “measure”:measureEvents,//当量算完成时触发. 需要传入当前绘制要素的geometry信息作为参数， 返回measure、units、order、geometry信息 “measurepartial”:measureEvents //当点被添加到量算过程中或timmediate 属性设为true，修改量算过程时触发. 返回measure、units、order、geometry信息。 }) map.addControl(measureControls)}function measureEvents(eve){ var iDiv=document.getElementById(“input”); if(eve.order==1){ iDiv.innerHTML=eve.measure+eve.units; }else{ iDiv.innerHTML=””+eve.measure+eve.units+”2“; }} 值得注意的是返回的geometry中，measure:表示测量结果；units:测量单位；order:order=1时表示距离测量；order=2时表示面积测量；geometry:绘制后的几何图形信息。","categories":[{"name":"WebGis","slug":"WebGis","permalink":"https://xinshani.github.io/categories/WebGis/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"},{"name":"OpenLayers","slug":"OpenLayers","permalink":"https://xinshani.github.io/tags/OpenLayers/"}]},{"title":"跨域及其解决办法","slug":"跨域及其解决办法","date":"2016-12-20T01:59:14.000Z","updated":"2022-04-06T01:45:23.124Z","comments":true,"path":"p/6151c7a8/","link":"","permalink":"https://xinshani.github.io/p/6151c7a8/","excerpt":"","text":"什么是跨域因为javascript的同源策略的限制，JS不能够操作另一个域名下的对象 URL 说明 是否允许通信 http://www.a.com/a.jshttp://www.a.com/b.js 同一域名下 允许 http://www.a.com/lab/a.jshttp://www.a.com/script/b.js 同一域名下不同文件夹 允许 http://www.a.com:8000/a.jshttp://www.a.com/b.js 同一域名，不同端口 不允许 http://www.a.com/a.jshttps://www.a.com/b.js 同一域名，不同协议 不允许 http://www.a.com/a.jshttp://70.32.92.74/b.js 域名和域名对应ip 不允许 http://www.a.com/a.jshttp://script.a.com/b.js 主域相同，子域不同 不允许 http://www.a.com/a.jshttp://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问） http://www.cnblogs.com/a.jshttp://www.a.com/b.js 不同域名 不允许 那么我们想用ajax去跨域是不可能的，ajax的xhr对象是无法拿到数据，但是有一种方法，凡是有src属性的其实都可以跨域，jsonp就是其中一种非标准的传输规范，它可以跨域。需要注意的是，我们用jsonp的话，其实就和ajax半毛钱的关系都没有了，原理完全不是一样的，我们用jsonp的话，相当于动态创建了一个script标签，使用script的src属性去请求，再通过回调函数把数据带回来，例如获取豆瓣api为例 //创建标签(createElement) var script = document.createElement(\"script\"); //添加地址 script.src='https://api.douban.com/v2/movie/1292052?callback=callbackD'; //添加给body的(成为body包涵的孩子) document.body.appendChild(script); //回调函数 function callbackD (data){ console.log(data) } 另外可以实现跨域的方法有很多，比如服务器代理php的header()、window.name、document.domain等等可以参考：简书文章","categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"}]},{"title":"url传值","slug":"url传值","date":"2016-12-15T02:16:34.000Z","updated":"2022-04-06T01:45:23.120Z","comments":true,"path":"p/bdaaf26b/","link":"","permalink":"https://xinshani.github.io/p/bdaaf26b/","excerpt":"","text":"有时候我们需要将A网页的数据在点击一次事件的时候，把 A 页面的某个值传到 B 页面里面，或者我们在 B 页面操作的时候，可能需要用到 A 页面的数据，才能做进一步操作，现在用这个为例： 我在 A 页面有 5 个 li,点击五个 li 的时候，会跳到 B 页面，B 页面里面的数据要根据 A 页面的数据动态生成。也就是说 B 页面是 5 组动态数据。 abcdef abcdef abcdef var a=document.getElementById(‘a’); var name=a.innerHTML; a.onclick=function(){ location.href=”b.html?”+name; } 那现在比如点击这几个li的时候，根据点击的不同，改变B 页面的里面的内容，开始写： var b=document.getElementById(‘b’); var request=window.location.search.substring((window.location.search.indexOf(“?”) + 1), window.location.search.length) b.innerHTML=request;","categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"}]},{"title":"Layer","slug":"layer","date":"2016-12-02T01:44:46.000Z","updated":"2022-04-06T01:45:23.119Z","comments":true,"path":"p/251a0e1e/","link":"","permalink":"https://xinshani.github.io/p/251a0e1e/","excerpt":"","text":"Layer |–TiledMapServiceLayer | |–ArcGISTiledMapServiceLayer |–DynamicLayer | |–DynamicMapServiceLayer | |–ArcGISDynamicMapServiceLayer | |–ArcGISImageServiceLayer | |–GPResultImageLayer |–GraphicsLayer | |–FeatureLayer |–ElementLayer Layer是最基本的基类，常用的几种图层类型已经用红色标记出来了。 （1）Layer：继承自DependencyObject，并实现了INotifyPropertyChanged接口，是其他图层的基类。 （2）TiledMapServiceLayer：继承自Layer，是所有使用了缓存的地图服务的基类。通过它可以在程序中加入经过缓存的，来自不同数据源的地图服务。比如ArcGIS Server的地图服务，Google Map的地图，Virtual Earth的地图等。 （3）ArcGISTiledMapServiceLayer：继承自TiledMapServiceLayer。这个图层扩展了TiledMapServiceLayer，支持由ArcGIS Server发布的经过缓存的地图服务。 （4）DynamicLayer：继承自Layer，是动态地图服务的基类。 （5）DynamicMapServiceLayer：继承自DynamicLayer，对应于TiledMapServiceLayer，要使用未经过缓存的动态地图服务，就得通过扩展这个图层来实现。 （6）ArcGISDynamicMapServiceLayer：继承自DynamicMapServiceLayer，针对ArcGIS Server 9.3版本发布的动态地图服务。同理，如果要在客户端API中使用其他动态地图服务，比如OGC的WMS服务，则也需要像这个图层一样，扩展上面的DynamicMapServiceLayer来实现。 （7）ArcGISImageServiceLayer：继承自DynamicMapServiceLayer，针对ArcGIS Server 9.3版本发布的Image Service，因为影像服务也属于动态的地图服务。在客户端API中，可以通过ArcGISImageServiceLayer的一些属性，方便通过浏览器来展示服务器端的影像数据，比如通过BandIds属性，可以快速调整影像数据显示波段的组合（RGB通道），提供不同结果供用户查看。点击这里，查看一个实例。 （8）GPResultImageLayer：继承自DynamicMapServiceLayer，针对Geoprocessing服务所产生的结果。可以请求服务器端的GP服务将结果动态生成一张图片，将此图片作为GPResultImageLayer图层直接添加到Map控件中。 （9）GraphicsLayer：继承自Layer，是图形数据集中展现的地方。GraphicsLayer是保留在内存中的一种图层（与ArcMap、ArcGIS Engine、ArcGIS Server ADF程序中的相应概念类似），顾名思义是很多Graphic的集合，而所有与用户交互的内容通常都用Graphic来显示。比如多边形查询中用户画出的多边形，属性/空间查询结果中的所有要素（Feature）等内容，都是Graphic。可以说，除了地图本身，基本上看到的所有与地理位置有关的东西都可以用Graphic来表示。Graphic对象有3个重要的属性：Geometry，Symbol和Attributes。Geometry代表了一个Graphic的几何形状（可疑是点、线、面任意一种）或地理位置，而Symbol则表示Graphic的呈现样子，比如颜色、效果，同时有了这两个属性（缺一不可），Graphic就可以显示到地图上了。而Attributes是键值对集合，可在里面存储任意类型的对象，比如一个要素的属性信息。 （10）FeatureLayer：继承自GraphicsLayer，这也是ArcGIS API for Silverlight/WPF 中的亮点之一，通过它可以完成一些比较炫的功能。FeatureLayer继承自GraphicsLayer，它与后者的区别是，GraphicsLayer中的Graphic都是人为创建出来的，而FeatureLayer中的Graphic都是从ArcGIS Server发布的服务中读取出来的，因此FeatureLayer比GraphicsLayer多了一个URL属性。这个URL通常指向一个ArcGIS Server发布的MapService或FeatureService的子图层（对应一个FeatureClass）。FeatureLayer有了这个URL后，就可以读取出该服务对应子图层里的所有要素内容，因此FeatureLayer里Graphic的Geometry属性会自动被FeatureClass的Shape字段填充，而Graphic的Attributes字段则会根据要求，被FeatureClass中的属性信息所填充。如果发布服务的服务器是ArcGIS Server 10版本，则Graphic的Symbol属性会自动被服务的DrawingInfo信息填充。另外，FeatureLayer是客户端API中对FeatureService的唯一载体，这是它另一个非常重要的作用（也是主要作用）。 （11）ElementLayer：继承自Layer，它可以用来专门呈现Silverlight/WPF中原生的FrameworkElement，比如视频，音频等。虽然在FillSymbol的Fill属性中也能利用Brush类来展现一段视频，但毕竟有些“小气”，在ElementLayer中可以大大方方的放置Silverlight/WPF元素。虽然在Map控件之外，Grid等布局元素中也能放置Silverlight的东西，但是ElementLayer的优势在于：当一些非地理数据元素随着地图范围的变化（放大，缩小，平移）的时候，无须在地图Extent变化后重新计算客户端坐标，再改变这些元素的位置。 ArcGISTiledMapServiceLayer和ArcGISDynamicMapServiceLayer分别用于加载ArcGIS Server发布的缓存地图服务和动态地图服务。GraphicsLayer和FeatureLayer，可以说这是API中最常用的两种图层，大部分的程序功能都要基于它们来完成。","categories":[{"name":"WebGis","slug":"WebGis","permalink":"https://xinshani.github.io/categories/WebGis/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"},{"name":"OpenLayers","slug":"OpenLayers","permalink":"https://xinshani.github.io/tags/OpenLayers/"}]},{"title":"esri.toolbars.Navigation","slug":"esri-toolbars-navigation","date":"2016-11-26T08:38:28.000Z","updated":"2022-04-06T01:45:23.119Z","comments":true,"path":"p/1424a4f0/","link":"","permalink":"https://xinshani.github.io/p/1424a4f0/","excerpt":"","text":"导入require(“esri/toolbars/Navigation”) 构造函数：esri.toolbars.Navigation(map); 有3个常量： PAN - 地图被平移。（漫游） ZOOM_IN - 地图放大。 ZOOM_OUT - 地图缩小。 方法： activate(navType)，激活地图导航工具栏；相对应的deactivate()，禁用工具栏并重新激活地图导航； sample： dojo.require(“esri/map”); dojo.require(“esri/toolbars/navigation”); function init (){ map = new esri.Map(“map”); scales=new esri.toolbars.Navigation(map); var layer = new esri.layers.ArcGISDynamicMapServiceLayer(“url”); map.addLayer(layer); } dojo.addOnLoad(init); //缩小 scales.activate(esri.toolbars.Navigation.ZOOM_OUT); //放大 scales.activate(esri.toolbars.Navigation.ZOOM_IN); //漫游 scales.activate(esri.toolbars.Navigation.PAN);","categories":[{"name":"webgis","slug":"webgis","permalink":"https://xinshani.github.io/categories/webgis/"}],"tags":[]},{"title":"clientX,screenX,pageX,offsetX","slug":"clientxscreenxpagexoffsetx","date":"2016-11-09T02:42:08.000Z","updated":"2022-04-06T01:45:23.118Z","comments":true,"path":"p/e9a6685a/","link":"","permalink":"https://xinshani.github.io/p/e9a6685a/","excerpt":"","text":"首先说明一下以上对象都是指javascript中的，不包含其他语言。pageX/pageY: 鼠标相对于整个页面的X/Y坐标。注意，整个页面的意思就是你整个网页的全部，比如说网页很宽很长，宽2000px，高3000px，那pageX,pageY的最大值就是它们了。 特别说明：IE不支持！ offsetX/offsetY: 得出的结果跟pageX/pageY一样，既然如此，它有什么存在价值？因为： 特别说明：只有IE支持！相当于IE下的pageX,pageY. screenX/screenY: 顾名思义，就是鼠标在屏幕上的坐标。screenX,screenY的最大值不会超过你的屏幕分辨率。 特别说明：无 clientX/clientY： 事件发生时鼠标在浏览器内容区域的X/Y坐标（不包含滚动条）。浏览器内容区域即浏览器窗口中用来显示网页的可视区域，注意这个可视，也就是说需要拖动滚动条才能看到的区域不算。当你将浏览器窗口缩小时，clientX/clientY的最大值也会缩小，但始终，它们的最大值不会超过你浏览器可视区域。 特别说明：IE下此属性不规范，它们的最小值不是0而是2，也就是说IE下的clientX/clientY与火狐下的始终大2px 网页可见区域宽： document.body.clientWidth; 网页可见区域高： document.body.clientHeight; 网页可见区域宽： document.body.offsetWidth (包括边线的宽); 网页可见区域高： document.body.offsetHeight (包括边线的宽); 网页正文全文宽： document.body.scrollWidth; 网页正文全文高： document.body.scrollHeight; 网页被卷去的高： document.body.scrollTop; 网页被卷去的左： document.body.scrollLeft; 网页正文部分上： window.screenTop; 网页正文部分左： window.screenLeft; 屏幕分辨率的高： window.screen.height; 屏幕分辨率的宽： window.screen.width; 屏幕可用工作区高度： window.screen.availHeight; 屏幕可用工作区宽度：window.screen.availWidth; jQuery: $(window).height(); //浏览器当前窗口可视区域高度 $(document).height(); //浏览器当前窗口文档的高度 $(document.body).height();//浏览器当前窗口文档body的高度 $(document.body).outerHeight(true);//浏览器当前窗口文档body的总高度 包括border padding margin $(window).width(); //浏览器当前窗口可视区域宽度 $(document).width();//浏览器当前窗口文档对象宽度 $(document.body).width();//浏览器当前窗口文档body的宽度 $(document.body).outerWidth(true));//浏览器当前窗口文档body的总宽度 包括border padding margin scrollHeight: 获取对象的滚动高度。 scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离 scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离 scrollWidth:获取对象的滚动宽度 offsetHeight:获取对象相对于版面或由父坐标 offsetParent 属性指定的父坐标的高度 offsetLeft:获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置 offsetTop:获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置 event.clientX 相对文档的水平座标 event.clientY 相对文档的垂直座标 event.offsetX 相对容器的水平坐标 event.offsetY 相对容器的垂直坐标 document.documentElement.scrollTop 垂直方向滚动的值 event.clientX+document.documentElement.scrollTop 相对文档的水平座标+垂直方向滚动的量","categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"}]},{"title":"xampp","slug":"xampp","date":"2016-10-20T06:30:45.000Z","updated":"2022-04-06T01:45:23.120Z","comments":true,"path":"p/b32f9ccc/","link":"","permalink":"https://xinshani.github.io/p/b32f9ccc/","excerpt":"","text":"停止mysql：用图形化工具或者在cmd命令下输入net stop mysql，在c盘根目录下输入 打开cmd，切换目录到 /xampp/mysql/bin, 运行 mysqld –skip-grant-tables 这条命令是跳过权限检查启动mysql服务 输完后enter这个窗口进入无法操作状态，保持这个窗口别关闭 3. 打开另一个cmd，同样切换目录到 /xampp/mysql/bin，运行 mysql –u root 用root登录到数据库 4. 修改root的密码 &gt;use mysql &gt;update user set password=PASSWORD(’新密码’) where user=’root’ &gt;flush privileges","categories":[{"name":"工具","slug":"工具","permalink":"https://xinshani.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://xinshani.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Docker","slug":"Docker","permalink":"https://xinshani.github.io/categories/Docker/"},{"name":"工具","slug":"工具","permalink":"https://xinshani.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"杂谈","slug":"杂谈","permalink":"https://xinshani.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"WebGis","slug":"WebGis","permalink":"https://xinshani.github.io/categories/WebGis/"},{"name":"webgis","slug":"webgis","permalink":"https://xinshani.github.io/categories/webgis/"}],"tags":[{"name":"MTProxy","slug":"MTProxy","permalink":"https://xinshani.github.io/tags/MTProxy/"},{"name":"SSR","slug":"SSR","permalink":"https://xinshani.github.io/tags/SSR/"},{"name":"FRP","slug":"FRP","permalink":"https://xinshani.github.io/tags/FRP/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://xinshani.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://xinshani.github.io/tags/ES6/"},{"name":"VUE","slug":"VUE","permalink":"https://xinshani.github.io/tags/VUE/"},{"name":"VS Code","slug":"VS-Code","permalink":"https://xinshani.github.io/tags/VS-Code/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://xinshani.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Node","slug":"Node","permalink":"https://xinshani.github.io/tags/Node/"},{"name":"javascript","slug":"javascript","permalink":"https://xinshani.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://xinshani.github.io/tags/React/"},{"name":"CSS","slug":"CSS","permalink":"https://xinshani.github.io/tags/CSS/"},{"name":"OpenLayers","slug":"OpenLayers","permalink":"https://xinshani.github.io/tags/OpenLayers/"},{"name":"git","slug":"git","permalink":"https://xinshani.github.io/tags/git/"}]}